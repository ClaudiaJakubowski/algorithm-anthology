\chapter{Strings}

\section{String Utilities}
\setcounter{section}{1}
\begin{lstlisting}
/*

Common string functions, many of which are substitutes for features which are
not available in standard C++, or may not be available on compilers that do not
support C++11 and later. These operations are naive implementations and often
depend on certain std::string functions that have unspecified complexity.

*/

#include <cctype>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>
using std::string;

/*

Integer Conversion

- to_str(i) returns the string representation of integer i, much like
  std::to_string() in C++11 and later.
- to_int(s) returns the integer representation of string s, much like atoi(),
  except handling special cases of overflow by throwing an exception.
- itoa(value, &str, base) implements the non-standard C function which converts
  value into a C string, storing it into pointer str in the given base. For more
  generalized base conversion, see the math utilities section.

*/

template<class Int>
string to_str(Int i) {
  std::ostringstream oss;
  oss << i;
  return oss.str();
}

int to_int(const string &s) {
  std::istringstream iss(s);
  int res;
  if (!(iss >> res)) {
    throw std::runtime_error("to_int failed");
  }
  return res;
}

char* itoa(int value, char *str, int base = 10) {
  if (base < 2 || base > 36) {
    *str = '\0';
    return str;
  }
  char *ptr = str, *ptr1 = str, tmp_c;
  int tmp_v;
  do {
    tmp_v = value;
    value /= base;
    *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789"
             "abcdefghijklmnopqrstuvwxyz"[35 + (tmp_v - value * base)];
  } while (value);
  if (tmp_v < 0) {
    *ptr++ = '-';
  }
  for (*ptr-- = '\0'; ptr1 < ptr; *ptr1++ = tmp_c) {
    tmp_c = *ptr;
    *ptr-- = *ptr1;
  }
  return str;
}

/*

Case Conversion

- to_upper(s) returns s with all alphabetical characters converted to uppercase.
- to_lower(s) returns s with all alphabetical characters converted to lowercase.
- to_title(s) returns the title case representation of string s, where the first
  letter of every word (consecutive alphabetical characters) is capitalized.

*/

string to_upper(const string &s) {
  string res;
  for (int i = 0; i < (int)s.size(); i++) {
    res.push_back(toupper(s[i]));
  }
  return res;
}

string to_lower(const string &s) {
  string res;
  for (int i = 0; i < (int)s.size(); i++) {
    res.push_back(tolower(s[i]));
  }
  return res;
}

string to_title(const string &s) {
  string res;
  char prev = '\0';
  for (int i = 0; i < (int)s.size(); i++) {
    if (isalpha(prev)) {
      res.push_back(tolower(s[i]));
    } else {
      res.push_back(toupper(s[i]));
    }
    prev = res.back();
  }
  return res;
}

/*

Stripping

- lstrip(s) strips the left side of s in-place (that is, the input is modified)
  using the given delimiters and returns a reference to the stripped string.
- rstrip(s) strips the right side of s in-place using the given delimiters and
  returns a reference to the stripped string.
- strip(s) strips both sides of s in-place and returns a reference to the
  stripped string.

*/

string& lstrip(string &s, const string &delim = " \n\t\v\f\r") {
  size_t pos = s.find_first_not_of(delim);
  if (pos != string::npos) {
    s.erase(0, pos);
  }
  return s;
}

string& rstrip(string &s, const string &delim = " \n\t\v\f\r") {
  size_t pos = s.find_last_not_of(delim);
  if (pos != string::npos) {
    s.erase(pos);
  }
  return s;
}

string& strip(string &s, const string &delim = " \n\t\v\f\r") {
  return lstrip(rstrip(s));
}

/*

Find and Replace

- find_all(haystack, needle) returns a vector of all positions where the string
  needle appears in the string haystack.
- replace(s, old, replacement) returns a copy of s with all occurrences of the
  string old replaced with the given replacement.

*/

std::vector<int> find_all(const string &haystack, const string &needle) {
  std::vector<int> res;
  size_t pos = haystack.find(needle, 0);
  while (pos != string::npos) {
      res.push_back(pos);
      pos = haystack.find(needle, pos + 1);
  }
  return res;
}

string replace(const string &s, const string &old, const string &replacement) {
  if (old.empty()) {
    return s;
  }
  string res(s);
  size_t pos = 0;
  while ((pos = res.find(old, pos)) != string::npos) {
    res.replace(pos, old.length(), replacement);
    pos += replacement.length();
  }
  return res;
}

/*

Joining and Splitting

- join(v, delim) returns the strings in vector v concatenated, separated by the
  given delimiter.
- split(s, char delim) returns a vector of tokens of s, split on a single
  character delimiter. Note that this version will not skip empty tokens. For
  example, split("a::b", ":") returns {"a", "b"}, not {"a", "", "b"}.
- split(s, string delim) returns a vector of tokens of s, split on a set of many
  possible single character delimiters. All characters ofz delim will be removed
  from s, and the remaining token(s) of s will be added sequentially to a vector
  and returned. Unlike the first version, empty tokens are skipped. For example,
  split("a::b", ":") returns {"a", "b"}, not {"a", "", "b"}.
- explode(s, delim) returns a vector of tokens of s, split on the entire
  delimiter string delim. Unlike the split() functions above, delim is treated
  as a contiguous boundary string, not merely a set of possible boundary
  characters. This will not skip empty tokens. For example,
  explode("a::::b", "::") yields {"a", "", "b"}, not {"a", "b"}.

*/

string join(const std::vector<string> &v, const string &delim = " ") {
  string res;
  for (int i = 0; i < (int)v.size(); i++) {
    if (i > 0) {
      res += delim;
    }
    res += v[i];
  }
  return res;
}

std::vector<string> split(const string &s, char delim) {
  std::vector<string> res;
  std::stringstream ss(s);
  string curr;
  while (std::getline(ss, curr, delim)) {
    res.push_back(curr);
  }
  return res;
}

std::vector<string> split(const string &s,
                          const string &delim = " \n\t\v\f\r") {
  std::vector<string> res;
  string curr;
  for (int i = 0; i < (int)s.size(); i++) {
    if (delim.find(s[i]) == string::npos) {
      curr += s[i];
    } else if (!curr.empty()) {
      res.push_back(curr);
      curr = "";
    }
  }
  if (!curr.empty()) {
    res.push_back(curr);
  }
  return res;
}

std::vector<string> explode(const string &s, const string &delim) {
  std::vector<string> res;
  size_t last = 0, next = 0;
  while ((next = s.find(delim, last)) != string::npos) {
    res.push_back(s.substr(last, (int)next - last));
    last = next + delim.size();
  }
  res.push_back(s.substr(last));
  return res;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  assert(to_str(123) + "4" == "1234");
  assert(to_int("1234") == 1234);
  char buffer[50];
  assert(string(itoa(1750, buffer, 10)) == "1750");
  assert(string(itoa(1750, buffer, 16)) == "6d6");
  assert(string(itoa(1750, buffer, 2)) == "11011010110");

  assert(to_upper("Hello world") == "HELLO WORLD");
  assert(to_lower("Hello World") == "hello world");
  assert(to_title("hello world") == "Hello World");

  string s("   abc \n");
  string t = s;
  assert(lstrip(s) == "abc \n");
  assert(rstrip(s) == strip(t));

  vector<int> pos;
  pos.push_back(0);
  pos.push_back(7);
  assert(find_all("abracadabra", "ab") == pos);
  assert(replace("abcdabba", "ab", "00") == "00cd00ba");

  assert(join(split("a\nb\ncde\nf", '\n'), "|") == "a|b|cde|f");  // split v1
  assert(join(split("a::b,cde:,f", ":,"), "|") == "a|b|cde|f");  // split v2
  assert(join(explode("a..b.cde....f", ".."), "|") == "a|b.cde||f");
  return 0;
}
\end{lstlisting}

\section{Expression Parsing}
\setcounter{section}{2}
\setcounter{subsection}{0}
\subsection{String Searching (KMP)}
\begin{lstlisting}
/*

Given a single string (needle) and subsequent queries of texts (haystacks) to be
searched, determine the first positions in which the needle occurs within the
given haystacks in linear time using the Knuth-Morris-Pratt algorithm. In
comparison, std::string::find runs in quadratic time.

- kmp(needle) constructs the partial match table for a string needle that is to
  be searched for subsequently in haystack queries.
- find_in(haystack) returns the first position that needle occurs in haystack,
  or std::string::npos if it cannot be found. Note that the function can be
  modified to return all matches by simply letting the loop run and storing
  the results instead of returning early.

Time Complexity:
- O(m) per call to the constructor, where m is the length of needle.
- O(n) per call to find_in(haystack), where n is the length of haystack.

Space Complexity:
- O(m) for storage of the partial match table, where m is the length of needle.
- O(1) auxiliary space per call to find_in(haystack).

*/

#include <string>
#include <vector>
using std::string;

class kmp {
  string needle;
  std::vector<int> table;

 public:
  kmp(const string &needle) : needle(needle) {
    table.resize(needle.size());
    int i = 0, j = table[0] = -1;
    while (i < (int)needle.size()) {
      while (j >= 0 && needle[i] != needle[j]) {
        j = table[j];
      }
      i++;
      j++;
      table[i] = (needle[i] == needle[j]) ? table[j] : j;
    }
  }

  size_t find_in(const string &haystack) {
    if (needle.empty()) {
      return 0;
    }
    for (int i = 0, j = 0; j < (int)haystack.size(); ) {
      while (i >= 0 && needle[i] != haystack[j]) {
        i = table[i];
      }
      i++;
      j++;
      if (i >= (int)needle.size()) {
        return j - i;
      }
    }
    return string::npos;
  }
};

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(15 == kmp("ABCDABD").find_in("ABC ABCDAB ABCDABCDABDE"));
  return 0;
}
\end{lstlisting}
\subsection{String Searching (Z Algorithm)}
\begin{lstlisting}
/*

Given a single string (needle) and a single text (haystack) to be searched,
determine the first position in which the needle occurs within the haystack in
linear time using the Z algorithm. In comparison, std::string::find runs in
quadratic time.

The find function below calls the Z algorithm on the concatenation of the needle
and the haystack, separated by a sentinel character (in this case '\0'), which
should be chosen such that it does not occur within either of the input strings.

- z_array(s) constructs the Z array for a string needle that can be used for
  string searching. The Z array on an input string s is an array z where z[i] is
  the length of the longest substring starting from s[i] which is also a prefix
  of s.
- find(needle, haystack) returns the first position that needle occurs in
  haystack, or std::string::npos if it cannot be found. Note that the function
  can be modified to return all matches by simply letting the loop run and
  storing the results instead of returning early.

Time Complexity:
- O(n) per call to z_array(s), where n is the length of s.
- O(n + m) per call to find(haystack, needle), where n is the length of haystack
  and m is the length of needle.

Space Complexity:
- O(n) auxiliary heap space for z_array(s), where n is the length of s.
- O(n + m) auxiliary heap space for find(haystack, needle) where n is the length
  of haystack and m is the length of needle.

*/

#include <algorithm>
#include <string>
#include <vector>
using std::string;

std::vector<int> z_array(const string &s) {
  std::vector<int> z(s.size());
  for (int i = 1, l = 0, r = 0; i < (int)z.size(); i++) {
    if (i <= r) {
      z[i] = std::min(r - i + 1, z[i - l]);
    }
    while (i + z[i] < (int)z.size() && s[z[i]] == s[i + z[i]]) {
      z[i]++;
    }
    if (r < i + z[i] - 1) {
      l = i;
      r = i + z[i] - 1;
    }
  }
  return z;
}

size_t find(const string &haystack, const string &needle) {
  std::vector<int> z = z_array(needle + '\0' + haystack);
  for (int i = (int)needle.size() + 1; i < (int)z.size(); i++) {
    if (z[i] == (int)needle.size()) {
      return i - (int)needle.size() - 1;
    }
  }
  return string::npos;
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(15 == find("ABC ABCDAB ABCDABCDABDE", "ABCDABD"));
  return 0;
}
\end{lstlisting}
\subsection{String Searching (Aho-Corasick)}
\begin{lstlisting}
/*

Given a set of strings (needles) and subsequent queries of texts (haystacks)
to be searched, determine all positions in which needles occur within the given
haystacks in linear time using the Aho-Corasick algorithm.

Note that this implementation uses an ordered map for storage of the graph,
adding an additional log k factor to the time complexities of all operations,
where k is the size of the alphabet (number of distinct characters used across
the needles). It also uses an ordered set for storage of the precomputed output
tables, adding an additional log m factor to the time complexities, where m is
the number of needles. In C++11 and later, both of these containers should be
replaced by their unordered versions for constant time access, thus eliminating
the log factors from the time complexities.

- aho_corasick(needles) constructs the finite-state automaton for a set of
  needle strings that are to be searched for subsequently in haystack queries.
- find_all_in(haystack, report_match) calls the function report_match(s, pos)
  once on each occurrence of each needle that occurs in the haystack, where pos
  is the starting position in the haystack at which string s (a matched needle)
  occurs. The matches will be reported in increasing order of their ending
  positions within the haystack.

Time Complexity:
- O(m*((log m) + l*log k)) per call to the constructor, where m is the number of
  needles, l is the maximum length for any needle, and k is the size of the
  alphabet used by the needles. If unordered containers are used, then the time
  complexity reduces to O(m*l), or linear on the input size.
- O(n*(log k) + z) per call to find_all_in(haystack, report_match), where n is
  the length of haystack, k is the size of the alphabet used by the needles, and
  z is the number of matches. If unordered containers are used, then the time
  complexity reduces to O(n + z), or linear on the input size.

Space Complexity:
- O(m*l) for storage of the automaton, where where m is the number of needles
  and l is the maximum length for any needle.
- O(1) auxiliary space per call to find_all_in(haystack, report_match).

*/

#include <map>
#include <queue>
#include <set>
#include <string>
#include <vector>
using std::string;

class aho_corasick {
  std::vector<string> needles;
  std::vector<int> fail;
  std::vector<std::map<char, int> > graph;
  std::vector<std::set<int> > out;

  int next_state(int curr, char c) {
    int next = curr;
    while (graph[next].find(c) == graph[next].end()) {
      next = fail[next];
    }
    return graph[next][c];
  }

 public:
  aho_corasick(const std::vector<string> &needles) : needles(needles) {
    int total_len = 0;
    for (int i = 0; i < (int)needles.size(); i++) {
      total_len += needles[i].size();
    }
    fail.resize(total_len, -1);
    graph.resize(total_len);
    out.resize(total_len);
    int states = 1;
    std::map<char, int>::iterator it;
    for (int i = 0; i < (int)needles.size(); i++) {
      int curr = 0;
      for (int j = 0; j < (int)needles[i].size(); j++) {
        char c = needles[i][j];
        if ((it = graph[curr].find(c)) != graph[curr].end()) {
          curr = it->second;
        } else {
          curr = graph[curr][c] = states++;
        }
      }
      out[curr].insert(i);
    }
    std::queue<int> q;
    for (it = graph[0].begin(); it != graph[0].end(); ++it) {
      if (it->second != 0) {
        fail[it->second] = 0;
        q.push(it->second);
      }
    }
    while (!q.empty()) {
      int u = q.front();
      q.pop();
      for (it = graph[u].begin(); it != graph[u].end(); ++it) {
        int v = it->second, f = fail[u];
        while (graph[f].find(it->first) == graph[f].end()) {
          f = fail[f];
        }
        f = graph[f].find(it->first)->second;
        fail[v] = f;
        out[v].insert(out[f].begin(), out[f].end());
        q.push(v);
      }
    }
  }

  template<class ReportFunction>
  void find_all_in(const string &haystack, ReportFunction report_match) {
    int state = 0;
    std::set<int>::iterator it;
    for (int i = 0; i < (int)haystack.size(); i++) {
      state = next_state(state, haystack[i]);
      for (it = out[state].begin(); it != out[state].end(); ++it) {
        report_match(needles[*it], i - needles[*it].size() + 1);
      }
    }
  }
};

/*** Example Usage and Output:

Matched "a" at position 0.
Matched "ab" at position 0.
Matched "bc" at position 1.
Matched "c" at position 2.
Matched "c" at position 3.
Matched "a" at position 4.
Matched "ab" at position 4.
Matched "abccab" at position 0.

***/

#include <iostream>
using namespace std;

void report_match(const string &needle, int pos) {
  cout << "Matched \"" << needle << "\" at position " << pos << "." << endl;
}

int main() {
  vector<string> needles;
  needles.push_back("a");
  needles.push_back("ab");
  needles.push_back("bab");
  needles.push_back("bc");
  needles.push_back("bca");
  needles.push_back("c");
  needles.push_back("caa");
  needles.push_back("abccab");

  aho_corasick(needles).find_all_in("abccab", report_match);
  return 0;
}
\end{lstlisting}

\section{String Searching}
\setcounter{section}{3}
\setcounter{subsection}{0}
\subsection{Recursive Descent Parsing (Simple)}
\begin{lstlisting}
/*

Evaluate an expression in accordance to the order of operations (parentheses,
unary plus and minus signs, multiplication/division, addition/subtraction). The
following is a minimalistic recursive descent implementation using iterators.

- eval(s) returns an evaluation of the arithmetic expression s.

Time Complexity:
- O(n) per call to eval(s), where n is the length of s.

Space Complexity:
- O(n) auxiliary stack space for eval(s), where n is the length of s.

*/

#include <string>

template<class It>
int eval(It &it, int prec) {
  if (prec == 0) {
    int sign = 1, ret = 0;
    for (; *it == '-'; it++) {
      sign *= -1;
    }
    if (*it == '(') {
      ret = eval(++it, 2);
      it++;
    } else while (*it >= '0' && *it <= '9') {
      ret = 10*ret + (*(it++) - '0');
    }
    return sign*ret;
  }
  int num = eval(it, prec - 1);
  while (!((prec == 2 && *it != '+' && *it != '-') ||
           (prec == 1 && *it != '*' && *it != '/'))) {
    switch (*(it++)) {
      case '+': num += eval(it, prec - 1); break;
      case '-': num -= eval(it, prec - 1); break;
      case '*': num *= eval(it, prec - 1); break;
      case '/': num /= eval(it, prec - 1); break;
    }
  }
  return num;
}

int eval(const std::string &s) {
  std::string::iterator it = std::string(s).begin();
  return eval(it, 2);
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(eval("1++1") == 2);
  assert(eval("1+2*3*4+3*(2+2)-100") == -63);
  return 0;
}
\end{lstlisting}
\subsection{Recursive Descent Parsing (Generic)}
\begin{lstlisting}
/*

Evaluate an expression using a generalized parser class for custom-defined
operand types, prefix unary operators, binary operators, and precedences.
Typical parentheses behavior is supported, but multiplication by juxtaposition
is not. Evaluation is performed using the recursive descent algorithm.

An arbitrary operand type is supported, with its string representation defined
by a user-specified is_operand() and eval_operand() functions. For maximum
reliability, the string representation of operands should not use characters
shared by any operator. For instance, the best practice instead of accepting
"-1" as a valid operand (since the "-" sign may conflict with the identical
binary operator), is to specify non-negative number as operands alongside the
unary operator "-".

Operators may be non-empty strings of any length, but should not contain any
parentheses or shared characters with the string representations of operands.
Ideally, operators should not be prefixes or suffices of one another, else the
tokenization process may be ambiguous. For example, if ++ and + are both
operators, then ++ may be split into either ["+", "+"] or ["++"] depending on
the lexicographical ordering of conflicting operators.

- parser(unary_op, binary_op) initializes a parser with operators specified by
  maps unary_op (of operator to function pointer) and binary_op (of operator to
  pair of function pointer and operator precedence). Operator precedences should
  be numbered upwards starting at 0 (lowest precedence, evaluated last).
- split(s) returns a vector of tokens for the expression s, split on the given
  operators during construction. Each parenthesis, operator, and operand
  satisfying is_operand() will be split into a separate token. The algorithm is
  naive, matching operators lazily in the case of overlapping operators as
  mentioned above. Under these circumstances, the parse may not always succeed.
- eval(lo, hi) returns the evaluation of a range [lo, hi) of already split-up
  expression tokens, where lo and hi must be random-access iterators.
- eval(s) returns the evaluation of expression s, after first calling split(s)
  to obtain the tokens.

Time Complexity:
- O(m) per call to the constructor, where m is the total number of operators.
- O(nmk) per call to split(s), where n is the length of s, m is the total number
  of operators defined for the parser instance, and k is the maximum length for
  any operator representation.
- O(n log m) per call to eval(lo, hi), where n is the distance between lo and hi
  and m is the total number of operators defined for the parser instance. In
  C++11 and later, std::unordered_map may be used in place of std::map for
  storing the unary_ops and binary_ops, which will eliminate the log m factor
  for a time complexity of O(n) per call.
- O(nmk + n log m) per call to eval(s), where n is the distance between lo and
  hi, and m and k are as defined previous.

Space Complexity:
- O(mk) for storage of the m operators, of maximum length k.
- O(n) auxiliary stack space for split(s), eval(lo, hi), and eval(s), where n is
  the length of the argument.

*/

#include <algorithm>
#include <cctype>
#include <functional>
#include <map>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>
using std::string;

// Define the custom operand type and representation below.
typedef double Operand;
typedef Operand (*UnaryOp)(Operand a);
typedef Operand (*BinaryOp)(Operand a, Operand b);

bool is_operand(const string &s) {
  int npoints = 0;
  for (int i = 0; i < (int)s.size(); i++) {
    if (s[i] == '.') {
      if (++npoints > 1) {
        return false;
      }
    } else if (!isdigit(s[i])) {
      return false;
    }
  }
  return !s.empty();
}

Operand eval_operand(const string &s) {
  Operand res;
  std::stringstream ss(s);
  ss >> res;
  return res;
}

class parser {
  typedef std::map<string, UnaryOp> unary_op_map;
  typedef std::map<string, std::pair<BinaryOp, int> > binary_op_map;
  unary_op_map unary_ops;
  binary_op_map binary_ops;
  std::set<string> ops;
  int max_precedence;

  template<class StrIt>
  Operand eval_unary(StrIt &lo, StrIt hi) {
    if (is_operand(*lo)) {
      return eval_operand(*(lo++));
    }
    unary_op_map::iterator it = unary_ops.find(*lo);
    if (it != unary_ops.end()) {
      return (it->second)(eval_unary(++lo, hi));
    }
    if (*lo != "(") {
      throw std::runtime_error("Expected \"(\" during eval.");
    }
    Operand res = eval_binary(++lo, hi, 0);
    if (*lo != ")") {
      throw std::runtime_error("Expected \")\" during eval.");
    }
    ++lo;
    return res;
  }

  template<class StrIt>
  Operand eval_binary(StrIt &lo, StrIt hi, Operand precedence) {
    if (precedence > max_precedence) {
      return eval_unary(lo, hi);
    }
    Operand v = eval_binary(lo, hi, precedence + 1);
    while (lo != hi) {
      binary_op_map::iterator it;
      it = binary_ops.find(*lo);
      if (it == binary_ops.end() || it->second.second != precedence) {
        return v;
      }
      v = (it->second.first)(v, eval_binary(++lo, hi, precedence + 1));
    }
    return v;
  }

  static string strip(string s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
  }

 public:
  parser(const unary_op_map &unary_ops, const binary_op_map &binary_ops)
      : unary_ops(unary_ops), binary_ops(binary_ops) {
    for (unary_op_map::const_iterator it = unary_ops.begin();
         it != unary_ops.end(); ++it) {
      ops.insert(it->first);
    }
    max_precedence = 0;
    for (binary_op_map::const_iterator it = binary_ops.begin();
         it != binary_ops.end(); ++it) {
      ops.insert(it->first);
      max_precedence = std::max(max_precedence, it->second.second);
    }
  }

  std::vector<string> split(const string &s) {
    std::vector<string> res;
    for (int i = 0; i < (int)s.size(); i++) {
      if (s[i] == ' ') {
        continue;
      }
      int next_paren = s.size();
      for (int j = i; j < (int)s.size(); j++) {
        if (s[j] == '(' || s[j] == ')') {
          next_paren = j;
          break;
        }
      }
      while (i < next_paren) {
        int found = next_paren;
        string found_op;
        for (int j = i; j < next_paren && found == next_paren; j++) {
          for (std::set<string>::iterator it = ops.begin();
               it != ops.end(); ++it) {
            if (s.substr(j, it->size()) == *it) {
              found = j;
              found_op = *it;
              break;
            }
          }
        }
        string term = strip(s.substr(i, found - i));
        if (!term.empty()) {
          res.push_back(term);
          if (!is_operand(term)) {
            throw std::runtime_error("Failed to split term: \"" + term + "\".");
          }
        }
        if (found < next_paren) {
          res.push_back(found_op);
          i = found + found_op.size();
        } else {
          i = next_paren;
        }
      }
      if (next_paren < s.size()) {
        res.push_back(string(1, s[next_paren]));
      }
    }
    return res;
  }

  template<class StrIt>
  Operand eval(StrIt lo, StrIt hi) {
    Operand res = eval_binary(lo, hi, 0);
    if (lo != hi) {
      throw std::runtime_error("Eval failed at token " + *lo + ".");
    }
    return res;
  }

  Operand eval(const string &s) {
    std::vector<string> tokens = split(s);
    return eval(tokens.begin(), tokens.end());
  }
};

/*** Example Usage ***/

#include <cassert>
#include <cmath>
using namespace std;

#define EQ(a, b) (fabs((a) - (b)) < 1e-7)

double pos(double a) { return +a; }
double neg(double a) { return -a; }
double add(double a, double b) { return a + b; }
double sub(double a, double b) { return a - b; }
double mul(double a, double b) { return a * b; }
double div(double a, double b) { return a / b; }

int main() {
  map<string, UnaryOp> unary_ops;
  unary_ops["+"] = pos;
  unary_ops["-"] = neg;

  map<string, pair<BinaryOp, int> > binary_ops;
  binary_ops["+"] = make_pair((BinaryOp)add, 0);
  binary_ops["-"] = make_pair((BinaryOp)sub, 0);
  binary_ops["*"] = make_pair((BinaryOp)mul, 1);
  binary_ops["/"] = make_pair((BinaryOp)div, 1);
  binary_ops["^"] = make_pair((BinaryOp)pow, 2);

  parser p(unary_ops, binary_ops);
  assert(EQ(p.eval("-+-((--(-+1)))"), -1));
  assert(EQ(p.eval("5*(3+3)-2-2"), 26));
  assert(EQ(p.eval("1+2*3*4+3*(+2)-100"), -69));
  assert(EQ(p.eval("3*3*3*3*3*3-2*2*2*2*2*2*2*2"), 473));
  assert(EQ(p.eval("3.14 + 3 * (7.7/9.8^32.9  )"), 3.14));
  assert(EQ(p.eval("5*(3+2)/-1*-2+(-2-2-2+3)-3-(-2)+15/2/2/2+(-2)"), 45.875));
  assert(EQ(p.eval("123456789./3/3/3*2*2*2+456/6-23/3"), 36579857.6666666667));
  assert(EQ(p.eval("10/3+10/4+10/5+10/6+10/7+10/8+10/9+10/10+15*23456"),
            351854.28968253968));
  assert(EQ(p.eval("-(5-(5-(5-(5-(5-2)))))+(3-(3-(3-(3-(3+3)))))*"
                   "(7-(7-(7-(7-(7-7+4*5)))))"), 117));
  return 0;
}
\end{lstlisting}
\subsection{Shunting Yard Parsing}
\begin{lstlisting}
/*

Evaluate an expression using a generalized parser class for custom-defined
operand types, prefix unary operators, binary operators, and precedences.
Typical parentheses behavior is supported, but multiplication by juxtaposition
is not. Evaluation is performed using the shunting yard algorithm.

An arbitrary operand type is supported, with its string representation defined
by a user-specified is_operand() and eval_operand() functions. For maximum
reliability, the string representation of operands should not use characters
shared by any operator. For instance, the best practice instead of accepting
"-1" as a valid operand (since the "-" sign may conflict with the identical
binary operator), is to specify non-negative number as operands alongside the
unary operator "-".

Operators may be non-empty strings of any length, but should not contain any
parentheses or shared characters with the string representations of operands.
Ideally, operators should not be prefixes or suffices of one another, else the
tokenization process may be ambiguous. For example, if ++ and + are both
operators, then ++ may be split into either ["+", "+"] or ["++"] depending on
the lexicographical ordering of conflicting operators.

- parser(unary_op, binary_op) initializes a parser with operators specified by
  maps unary_op (of operator to function pointer) and binary_op (of operator to
  pair of function pointer and operator precedence). Operator precedences should
  be numbered upwards starting at 0 (lowest precedence, evaluated last).
- split(s) returns a vector of tokens for the expression s, split on the given
  operators during construction. Each parenthesis, operator, and operand
  satisfying is_operand() will be split into a separate token. The algorithm is
  naive, matching operators lazily in the case of overlapping operators as
  mentioned above. Under these circumstances, the parse may not always succeed.
- eval(lo, hi) returns the evaluation of a range [lo, hi) of already split-up
  expression tokens, where lo and hi must be random-access iterators.
- eval(s) returns the evaluation of expression s, after first calling split(s)
  to obtain the tokens.

Time Complexity:
- O(m) per call to the constructor, where m is the total number of operators.
- O(nmk) per call to split(s), where n is the length of s, m is the total number
  of operators defined for the parser instance, and k is the maximum length for
  any operator representation.
- O(n log m) per call to eval(lo, hi), where n is the distance between lo and hi
  and m is the total number of operators defined for the parser instance. In
  C++11 and later, std::unordered_map may be used in place of std::map for
  storing the unary_ops and binary_ops, which will eliminate the log m factor
  for a time complexity of O(n) per call.
- O(nmk + n log m) per call to eval(s), where n is the distance between lo and
  hi, and m and k are as defined previous.

Space Complexity:
- O(mk) for storage of the m operators, of maximum length k.
- O(n) auxiliary stack space for split(s), eval(lo, hi), and eval(s), where n is
  the length of the argument.

*/

#include <algorithm>
#include <cctype>
#include <functional>
#include <map>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>
using std::string;

// Define the custom operand type and representation below.
typedef double Operand;
typedef Operand (*UnaryOp)(Operand a);
typedef Operand (*BinaryOp)(Operand a, Operand b);

bool is_operand(const string &s) {
  int npoints = 0;
  for (int i = 0; i < (int)s.size(); i++) {
    if (s[i] == '.') {
      if (++npoints > 1) {
        return false;
      }
    } else if (!isdigit(s[i])) {
      return false;
    }
  }
  return !s.empty();
}

Operand eval_operand(const string &s) {
  Operand res;
  std::stringstream ss(s);
  ss >> res;
  return res;
}

class parser {
  typedef std::map<string, UnaryOp> unary_op_map;
  typedef std::map<string, std::pair<BinaryOp, int> > binary_op_map;
  unary_op_map unary_ops;
  binary_op_map binary_ops;
  std::set<string> ops;

  static string strip(string s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
  }

 public:
  parser(const unary_op_map &unary_ops, const binary_op_map &binary_ops)
      : unary_ops(unary_ops), binary_ops(binary_ops) {
    for (unary_op_map::const_iterator it = unary_ops.begin();
         it != unary_ops.end(); ++it) {
      ops.insert(it->first);
    }
    for (binary_op_map::const_iterator it = binary_ops.begin();
         it != binary_ops.end(); ++it) {
      ops.insert(it->first);
    }
  }

  std::vector<string> split(const string &s) {
    std::vector<string> res;
    for (int i = 0; i < (int)s.size(); i++) {
      if (s[i] == ' ') {
        continue;
      }
      int next_paren = s.size();
      for (int j = i; j < (int)s.size(); j++) {
        if (s[j] == '(' || s[j] == ')') {
          next_paren = j;
          break;
        }
      }
      while (i < next_paren) {
        int found = next_paren;
        string found_op;
        for (int j = i; j < next_paren && found == next_paren; j++) {
          for (std::set<string>::iterator it = ops.begin();
               it != ops.end(); ++it) {
            if (s.substr(j, it->size()) == *it) {
              found = j;
              found_op = *it;
              break;
            }
          }
        }
        string term = strip(s.substr(i, found - i));
        if (!term.empty()) {
          res.push_back(term);
          if (!is_operand(term)) {
            throw std::runtime_error("Failed to split term: \"" + term + "\".");
          }
        }
        if (found < next_paren) {
          res.push_back(found_op);
          i = found + found_op.size();
        } else {
          i = next_paren;
        }
      }
      if (next_paren < s.size()) {
        res.push_back(string(1, s[next_paren]));
      }
    }
    return res;
  }

  template<class StrIt>
  Operand eval(StrIt lo, StrIt hi) {
    std::stack<Operand> vals;
    std::stack<std::pair<string, bool> > ops;
    ops.push(std::make_pair("(", false));
    StrIt prev = hi;
    do {
      string curr = (lo == hi) ? ")" : *lo;
      if (is_operand(curr)) {
        vals.push(eval_operand(curr));
      } else if (curr == "(") {
        ops.push(std::make_pair(curr, false));
      } else if (unary_ops.find(curr) != unary_ops.end() && (prev == hi ||
                 *prev == "(" || binary_ops.find(*prev) != binary_ops.end())) {
        ops.push(std::make_pair(curr, true));
      } else {
        for (;;) {
          string op = ops.top().first;
          bool is_unary = ops.top().second;
          binary_op_map::iterator it1 = binary_ops.find(op);
          binary_op_map::iterator it2 = binary_ops.find(curr);
          if (!is_unary &&
              (it1 == binary_ops.end() ? -1 : it1->second.second) <
              (it2 == binary_ops.end() ? -1 : it2->second.second)) {
            break;
          }
          ops.pop();
          if (op == "(") {
            break;
          }
          Operand b = vals.top();
          vals.pop();
          if (is_unary) {
            unary_op_map::iterator it = unary_ops.find(op);
            if (it == unary_ops.end()) {
              throw std::runtime_error("Failed to eval unary op: " + op);
            }
            vals.push((it->second)(b));
          } else {
            Operand a = vals.top();
            vals.pop();
            if (it1 == binary_ops.end()) {
              throw std::runtime_error("Failed to eval binary op: " + op);
            }
            vals.push((it1->second.first)(a, b));
          }
        }
        if (curr != ")") {
          ops.push(std::make_pair(*lo, false));
        }
      }
      prev = lo;
    } while (lo++ != hi);
    return vals.top();
  }

  Operand eval(const string &s) {
    std::vector<string> tokens = split(s);
    return eval(tokens.begin(), tokens.end());
  }
};

/*** Example Usage ***/

#include <cassert>
#include <cmath>
using namespace std;

#define EQ(a, b) (fabs((a) - (b)) < 1e-7)

double pos(double a) { return +a; }
double neg(double a) { return -a; }
double add(double a, double b) { return a + b; }
double sub(double a, double b) { return a - b; }
double mul(double a, double b) { return a * b; }
double div(double a, double b) { return a / b; }

int main() {
  map<string, UnaryOp> unary_ops;
  unary_ops["+"] = pos;
  unary_ops["-"] = neg;

  map<string, pair<BinaryOp, int> > binary_ops;
  binary_ops["+"] = make_pair((BinaryOp)add, 0);
  binary_ops["-"] = make_pair((BinaryOp)sub, 0);
  binary_ops["*"] = make_pair((BinaryOp)mul, 1);
  binary_ops["/"] = make_pair((BinaryOp)div, 1);
  binary_ops["^"] = make_pair((BinaryOp)pow, 2);

  parser p(unary_ops, binary_ops);
  assert(EQ(p.eval("-+-((--(-+1)))"), -1));
  assert(EQ(p.eval("5*(3+3)-2-2"), 26));
  assert(EQ(p.eval("1+2*3*4+3*(+2)-100"), -69));
  assert(EQ(p.eval("3*3*3*3*3*3-2*2*2*2*2*2*2*2"), 473));
  assert(EQ(p.eval("3.14 + 3 * (7.7/9.8^32.9  )"), 3.14));
  assert(EQ(p.eval("5*(3+2)/-1*-2+(-2-2-2+3)-3-(-2)+15/2/2/2+(-2)"), 45.875));
  assert(EQ(p.eval("123456789./3/3/3*2*2*2+456/6-23/3"), 36579857.6666666667));
  assert(EQ(p.eval("10/3+10/4+10/5+10/6+10/7+10/8+10/9+10/10+15*23456"),
            351854.28968253968));
  assert(EQ(p.eval("-(5-(5-(5-(5-(5-2)))))+(3-(3-(3-(3-(3+3)))))*"
                   "(7-(7-(7-(7-(7-7+4*5)))))"), 117));
  return 0;
}
\end{lstlisting}

\section{Dynamic Programming}
\setcounter{section}{4}
\setcounter{subsection}{0}
\subsection{Longest Common Substring}
\begin{lstlisting}
/*

Given two strings, determine their longest common substring (i.e. consecutive
subsequence) using dynamic programming.

Time Complexity:
- O(n*m) per call to longest_common_substring(s1, s2), where n and m are the
  lengths of s1 and s2, respectively.

Space Complexity:
- O(min(n, m)) auxiliary heap space, where n and m are the lengths of s1 and
  s2, respectively.

*/

#include <string>
#include <vector>
using std::string;

string longest_common_substring(const string &s1, const string &s2) {
  int n = s1.size(), m = s2.size();
  if (n == 0 || m == 0) {
    return "";
  }
  if (n < m) {
    return longest_common_substring(s2, s1);
  }
  std::vector<int> curr(m), prev(m);
  int pos = 0, len = 0;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (s1[i] == s2[j]) {
        curr[j] = (i > 0 && j > 0) ? prev[j - 1] + 1 : 1;
        if (len < curr[j]) {
          len = curr[j];
          pos = i - curr[j] + 1;
        }
      } else {
        curr[j] = 0;
      }
    }
    curr.swap(prev);
  }
  return s1.substr(pos, len);
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(longest_common_substring("bbbabca", "aababcd") == "babc");
  return 0;
}
\end{lstlisting}
\subsection{Longest Common Subsequence}
\begin{lstlisting}
/*

Given two strings, determine their longest common subsequence. A subsequence is
a string that can be derived from the original string by deleting some elements
without changing the order of the remaining elements (e.g. "ACE" is a
subsequence of "ABCDE", but "BAE" is not).

- longest_common_subsequence(s1, s2) returns the longest common subsequence of
  strings s1 and s2 using a classic dynamic programming approach. This
  implementation computes dp[i][j] (the length of the longest common subsequence
  for the length i prefix of s1 and the length j prefix of s2) before following
  the path backwards to construct the answer.
- hirschberg_lcs(s1, s2) returns the longest common subsequence of strings s1
  and s2 using the more memory efficient Hirschberg's algorithm.

Time Complexity:
- O(n*m) per call to longest_common_subsequence(s1, s2) as well as
  hirschberg_lcs(s1, s2), where n and m are the lengths of s1 and s2,
  respectively.

Space Complexity:
- O(n*m) auxiliary heap space for longest_common_subsequence(s1, s2), where n
  and m are the lengths of s1 and s2, respectively.
- O(log max(n, m)) auxiliary stack space and O(min(n, m)) auxiliary heap space
  for hirschberg_lcs(s1, s2), where n and m are the lengths of s1 and s2,
  respectively.

*/

#include <algorithm>
#include <iterator>
#include <string>
#include <vector>
using std::string;

string longest_common_subsequence(const string &s1, const string &s2) {
  int n = s1.size(), m = s2.size();
  std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (s1[i - 1] == s2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = std::max(dp[i][j - 1], dp[i - 1][j]);
      }
    }
  }
  string res;
  for (int i = n, j = m; i > 0 && j > 0; ) {
    if (s1[i - 1] == s2[j - 1]) {
      res += s1[i - 1];
      i--;
      j--;
    } else if (dp[i - 1][j] >= dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }
  std::reverse(res.begin(), res.end());
  return res;
}

template<class It>
std::vector<int> lcs_len(It lo1, It hi1, It lo2, It hi2) {
  std::vector<int> res(std::distance(lo2, hi2) + 1), prev(res);
  for (It it1 = lo1; it1 != hi1; ++it1) {
    res.swap(prev);
    int i = 0;
    for (It it2 = lo2; it2 != hi2; ++it2) {
      res[i + 1] = (*it1 == *it2) ? prev[i] + 1 : std::max(res[i], prev[i + 1]);
      i++;
    }
  }
  return res;
}

template<class It>
void hirschberg_rec(It lo1, It hi1, It lo2, It hi2, string *res) {
  if (lo1 == hi1) {
    return;
  }
  if (lo1 + 1 == hi1) {
    if (std::find(lo2, hi2, *lo1) != hi2) {
      *res += *lo1;
    }
    return;
  }
  It mid1 = lo1 + (hi1 - lo1)/2;
  std::reverse_iterator<It> rlo1(hi1), rmid1(mid1), rlo2(hi2), rhi2(lo2);
  std::vector<int> fwd = lcs_len(lo1, mid1, lo2, hi2);
  std::vector<int> rev = lcs_len(rlo1, rmid1, rlo2, rhi2);
  It mid2 = lo2;
  int maxlen = -1;
  for (int i = 0, j = (int)rev.size() - 1; i < (int)fwd.size(); i++, j--) {
    if (fwd[i] + rev[j] > maxlen) {
      maxlen = fwd[i] + rev[j];
      mid2 = lo2 + i;
    }
  }
  hirschberg_rec(lo1, mid1, lo2, mid2, res);
  hirschberg_rec(mid1, hi1, mid2, hi2, res);
}

string hirschberg_lcs(const string &s1, const string &s2) {
  if (s1.size() < s2.size()) {
    return hirschberg_lcs(s2, s1);
  }
  string res;
  hirschberg_rec(s1.begin(), s1.end(), s2.begin(), s2.end(), &res);
  return res;
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(longest_common_subsequence("xmjyauz", "mzjawxu") == "mjau");
  assert(hirschberg_lcs("xmjyauz", "mzjawxu") == "mjau");
  return 0;
}
\end{lstlisting}
\subsection{Sequence Alignment}
\begin{lstlisting}
/*

Given two strings, determine their minimum-cost alignment. An alignment of two
strings is a transformation of both strings by inserting gap characters '_' in
some way to make the final lengths equal. The total cost of an alignment given
a gap_cost (insertion or deletion cost) and a sub_cost (substitution, i.e.
mismatch cost) is gap_cost*(the number of gaps inserted across both strings),
plus sub_cost*(the number of indices at which the two aligned strings differ).

- align_sequences(s1, s2, gap_cost, sub_cost) returns a pair of aligned strings
  for strings s1 and s2, using a classic dynamic programming approach. This
  implementation first computes dp[i][j] (the cost of aligning the length i
  prefix of s1 with the length j prefix of s2) before following the path
  backwards to construct the answer. For gap_cost = sub_cost = 1, dp[n][m] will
  be the Levenshtein edit distance, where n and m are the lengths of s1 and
  s2, respectively.
- hirschberg_align_sequences(s1, s2, gap_cost, sub_cost) returns the sequence
  alignment of strings s1 and s2 using the more memory efficient Hirschberg's
  algorithm.

Time Complexity:
- O(n*m) per call to align_sequences(s1, s2) as well as
  hirschberg_align_sequences(s1, s2), where n and m are the lengths of s1 and
  s2, respectively.

Space Complexity:
- O(n*m) auxiliary heap space for align_sequences(s1, s2), where n and m are the
  lengths of s1 and s2, respectively.
- O(log max(n, m)) auxiliary stack space and O(min(n, m)) auxiliary heap space
  for hirschberg_align_sequences(s1, s2), where n and m are the lengths of s1
  and s2, respectively.

*/

#include <algorithm>
#include <string>
#include <vector>
#include <utility>
using std::string;

std::pair<string, string> align_sequences(
    const string &s1, const string &s2, int gap_cost = 1, int sub_cost = 1) {
  int n = s1.size(), m = s2.size();
  std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));
  for (int i = 0; i <= n; i++) {
    dp[i][0] = i*gap_cost;
  }
  for (int j = 0; j <= m; j++) {
    dp[0][j] = j*gap_cost;
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      dp[i][j] = (s1[i - 1] == s2[j - 1]) ? dp[i - 1][j - 1] : std::min(
          dp[i - 1][j - 1] + sub_cost,
          std::min(dp[i - 1][j], dp[i][j - 1]) + gap_cost);
    }
  }
  string res1, res2;
  int i = n, j = m;
  while (i > 0 && j > 0) {
    if (s1[i - 1] == s2[j - 1] || dp[i][j] == dp[i - 1][j - 1] + sub_cost) {
      res1 += s1[--i];
      res2 += s2[--j];
    } else if (dp[i][j] == dp[i - 1][j] + gap_cost) {
      res1 += s1[--i];
      res2 += '_';
    } else if (dp[i][j] == dp[i][j - 1] + gap_cost) {
      res1 += '_';
      res2 += s2[--j];
    }
  }
  while (i > 0 || j > 0) {
    res1 += (i > 0) ? s1[--i] : '_';
    res2 += (j > 0) ? s2[--j] : '_';
  }
  std::reverse(res1.begin(), res1.end());
  std::reverse(res2.begin(), res2.end());
  return std::make_pair(res1, res2);
}

template<class It>
std::vector<int> row_cost(It lo1, It hi1, It lo2, It hi2,
                          int gap_cost, int sub_cost) {
  std::vector<int> res(std::distance(lo2, hi2) + 1), prev(res);
  for (It it1 = lo1; it1 != hi1; ++it1) {
    res.swap(prev);
    int i = 0;
    for (It it2 = lo2; it2 != hi2; ++it2) {
      res[i + 1] = (*it1 == *it2) ? prev[i] : std::min(prev[i] + sub_cost,
                                                       res[i] + gap_cost);
      i++;
    }
  }
  return res;
}

template<class It>
void hirschberg_rec(It lo1, It hi1, It lo2, It hi2,
                    string *res1, string *res2, int gap_cost, int sub_cost) {
  if (lo1 == hi1) {
    for (It it2 = lo2; it2 != hi2; ++it2) {
      *res1 += '_';
      *res2 += *it2;
    }
    return;
  }
  if (lo1 + 1 == hi1) {
    It pos = std::find(lo2, hi2, *lo1);
    bool insert = (pos == hi2) && (gap_cost*(hi2 - lo2 + 1) < sub_cost);
    if (lo2 == hi2 || insert) {
      *res1 += *lo1;
      *res2 += '_';
    }
    for (It it2 = lo2; it2 != hi2; ++it2) {
      *res1 += (pos == it2 || (!insert && it2 == lo2)) ? *lo1 : '_';
      *res2 += *it2;
    }
    return;
  }
  It mid1 = lo1 + (hi1 - lo1)/2;
  std::reverse_iterator<It> rlo1(hi1), rmid1(mid1), rlo2(hi2), rhi2(lo2);
  std::vector<int> fwd = row_cost(lo1, mid1, lo2, hi2, gap_cost, sub_cost);
  std::vector<int> rev = row_cost(rlo1, rmid1, rlo2, rhi2, gap_cost, sub_cost);
  It mid2 = lo2;
  int mincost = -1;
  for (int i = 0, j = (int)rev.size() - 1; i < (int)fwd.size(); i++, j--) {
    if (mincost < 0 || fwd[i] + rev[j] < mincost) {
      mincost = fwd[i] + rev[j];
      mid2 = lo2 + i;
    }
  }
  hirschberg_rec(lo1, mid1, lo2, mid2, res1, res2, gap_cost, sub_cost);
  hirschberg_rec(mid1, hi1, mid2, hi2, res1, res2, gap_cost, sub_cost);
}

std::pair<string, string> hirschberg_align_sequences(
    const string &s1, const string &s2, int gap_cost = 1, int sub_cost = 1) {
  if (s1.size() < s2.size()) {
    return hirschberg_align_sequences(s2, s1, gap_cost, sub_cost);
  }
  string res1, res2;
  hirschberg_rec(s1.begin(), s1.end(), s2.begin(), s2.end(), &res1, &res2,
                 gap_cost, sub_cost);
  return std::make_pair(res1, res2);
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(align_sequences("AGGGCT", "AGGCA", 2, 3) ==
             make_pair(string("AGGGCT"), string("A_GGCA")));
  assert(hirschberg_align_sequences("AGGGCT", "AGGCA", 2, 3) ==
             make_pair(string("AGGGCT"), string("A_GGCA")));
  return 0;
}
\end{lstlisting}

\section{Suffix Array and LCP}
\setcounter{section}{5}
\setcounter{subsection}{0}
\subsection{Suffix Array and LCP (Manber-Myers)}
\begin{lstlisting}
/*

Given a string s, a suffix array is the array of the smallest starting positions
for the sorted suffices of s. That is, the i-th position of the suffix array
stores the starting position of the i-th lexicographically smallest suffix of s.
For examples, s = "cab" has the suffices "cab", "ab", and "b". When sorted, the
indices of the suffixes are "ab", "b", and "cab", so the suffix array (assuming
zero-based indices) is [1, 2, 0].

For a string s of length n the longest common prefix (LCP) array of length n - 1
stores the lengths of the longest common prefixes between all pairs of
lexicographically adjacent suffices in s. For example, "baa" has the sorted
suffices "a", "aa", and "baa", with an LCP array of [1, 0].

- suffix_array(s) constructs a suffix array from the given string s using the
  original Manber-Myers gap partitioning algorithm with a comparison-based sort.
- get_sa() returns the constructed suffix array.
- get_lcp() returns the corresponding LCP array for the suffix array.
- find(needle) returns one position that needle occurs in s (not necessarily the
  first), or std::string::npos if it cannot be found. For a needle of length m,
  this implementation uses an O(m log n) binary search, but can be optimized to
  O(m + log n) by first computing the LCP-LR array using the LCP array.

Time Complexity:
- O(n log^2 n) per call to the constructor, where n is the length of s.
- O(1) per call to get_sa().
- O(n) per call to get_lcp(), where n is the length of s.
- O(m log n) per call to find(needle), where m is the length of needle and n is
  the length of s.

Space Complexity:
- O(n) auxiliary for storage of the suffix and LCP arrays, where n is the length
  of s.
- O(n) auxiliary heap space for the constructor.
- O(1) auxiliary space for all other operations.

*/

#include <algorithm>
#include <string>
#include <utility>
#include <vector>
using std::string;

class suffix_array {
  struct comp {
    const std::vector<std::pair<int, int> > &rank;

    comp(const std::vector<std::pair<int, int> > &rank) : rank(rank) {}

    bool operator()(int i, int j) {
      return rank[i] < rank[j];
    }
  };

  string s;
  std::vector<int> sa, rank;

 public:
  suffix_array(const string &s) : s(s), sa(s.size()), rank(s.size()) {
    int n = s.size();
    for (int i = 0; i < n; i++) {
      sa[i] = i;
      rank[i] = (int)s[i];
    }
    std::vector<std::pair<int, int> > rank2(n);
    for (int gap = 1; gap < n; gap *= 2) {
      for (int i = 0; i < n; i++) {
        rank2[i] = std::make_pair(rank[i], i + gap < n ? rank[i + gap] + 1 : 0);
      }
      std::sort(sa.begin(), sa.end(), comp(rank2));
      for (int i = 0; i < n; i++) {
        rank[sa[i]] = (i > 0 && rank2[sa[i - 1]] == rank2[sa[i]])
                      ? rank[sa[i - 1]] : i;
      }
    }
  }

  std::vector<int> get_sa() {
    return sa;
  }

  std::vector<int> get_lcp() {
    int n = s.size();
    std::vector<int> lcp(n - 1);
    for (int i = 0, k = 0; i < n; i++) {
      if (rank[i] < n - 1) {
        int j = sa[rank[i] + 1];
        while (std::max(i, j) + k < n && s[i + k] == s[j + k]) {
          k++;
        }
        lcp[rank[i]] = k;
        if (k > 0) {
          k--;
        }
      }
    }
    return lcp;
  }

  size_t find(const string &needle) {
    int lo = 0, hi = (int)s.size() - 1;
    while (lo <= hi) {
      int mid = lo + (hi - lo)/2;
      int cmp = s.compare(sa[mid], needle.size(), needle);
      if (cmp < 0) {
        lo = mid + 1;
      } else if (cmp > 0) {
        hi = mid - 1;
      } else {
        return sa[mid];
      }
    }
    return string::npos;
  }
};

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  suffix_array sa("banana");
  vector<int> sarr = sa.get_sa(), lcp = sa.get_lcp();
  int sarr_expected[] = {5, 3, 1, 0, 4, 2};
  int lcp_expected[] = {1, 3, 0, 0, 2};
  assert(equal(sarr.begin(), sarr.end(), sarr_expected));
  assert(equal(lcp.begin(), lcp.end(), lcp_expected));
  assert(sa.find("ana") == 1);
  assert(sa.find("x") == string::npos);
  return 0;
}
\end{lstlisting}
\subsection{Suffix Array and LCP (Counting Sort)}
\begin{lstlisting}
/*

Given a string s, a suffix array is the array of the smallest starting positions
for the sorted suffices of s. That is, the i-th position of the suffix array
stores the starting position of the i-th lexicographically smallest suffix of s.
For examples, s = "cab" has the suffices "cab", "ab", and "b". When sorted, the
indices of the suffixes are "ab", "b", and "cab", so the suffix array (assuming
zero-based indices) is [1, 2, 0].

For a string s of length n the longest common prefix (LCP) array of length n - 1
stores the lengths of the longest common prefixes between all pairs of
lexicographically adjacent suffices in s. For example, "baa" has the sorted
suffices "a", "aa", and "baa", with an LCP array of [1, 0].

- suffix_array(s) constructs a suffix array from the given string s using the
  original Manber-Myers gap partitioning algorithm with a counting sort instead
  of a comparison-based sort to reduce the running time to O(n log n).
- get_sa() returns the constructed suffix array.
- get_lcp() returns the corresponding LCP array for the suffix array.
- find(needle) returns one position that needle occurs in s (not necessarily the
  first), or std::string::npos if it cannot be found. For a needle of length m,
  this implementation uses an O(m log n) binary search, but can be optimized to
  O(m + log n) by first computing the LCP-LR array using the LCP array.

Time Complexity:
- O(n log n) per call to the constructor, where n is the length of s.
- O(1) per call to get_sa().
- O(n) per call to get_lcp(), where n is the length of s.
- O(m log n) per call to find(needle), where m is the length of needle and n is
  the length of s.

Space Complexity:
- O(n) auxiliary for storage of the suffix and LCP arrays, where n is the length
  of s.
- O(n) auxiliary heap space for the constructor.
- O(1) auxiliary space for all other operations.

*/

#include <algorithm>
#include <string>
#include <utility>
#include <vector>
using std::string;

class suffix_array {
  struct comp {
    const string &s;

    comp(const string &s) : s(s) {}

    bool operator()(int i, int j) {
      return s[i] < s[j];
    }
  };

  string s;
  std::vector<int> sa, rank;

 public:
  suffix_array(const string &s) : s(s), sa(s.size()), rank(s.size()) {
    int n = s.size();
    for (int i = 0; i < n; i++) {
      sa[i] = n - 1 - i;
      rank[i] = (int)s[i];
    }
    std::stable_sort(sa.begin(), sa.end(), comp(s));
    for (int gap = 1; gap < n; gap *= 2) {
      std::vector<int> prev_rank(rank), prev_sa(sa), cnt(n);
      for (int i = 0; i < n; i++) {
        cnt[i] = i;
      }
      for (int i = 0; i < n; i++) {
        rank[sa[i]] = (i > 0 && prev_rank[sa[i - 1]] == prev_rank[sa[i]] &&
                       sa[i - 1] + gap < n &&
                       prev_rank[sa[i - 1] + gap/2] == prev_rank[sa[i] + gap/2])
                           ? rank[sa[i - 1]] : i;
      }
      for (int i = 0; i < n; i++) {
        int s1 = prev_sa[i] - gap;
        if (s1 >= 0) {
          sa[cnt[rank[s1]]++] = s1;
        }
      }
    }
  }

  std::vector<int> get_sa() {
    return sa;
  }

  std::vector<int> get_lcp() {
    int n = s.size();
    std::vector<int> lcp(n - 1);
    for (int i = 0, k = 0; i < n; i++) {
      if (rank[i] < n - 1) {
        int j = sa[rank[i] + 1];
        while (std::max(i, j) + k < n && s[i + k] == s[j + k]) {
          k++;
        }
        lcp[rank[i]] = k;
        if (k > 0) {
          k--;
        }
      }
    }
    return lcp;
  }

  size_t find(const string &needle) {
    int lo = 0, hi = (int)s.size() - 1;
    while (lo <= hi) {
      int mid = lo + (hi - lo)/2;
      int cmp = s.compare(sa[mid], needle.size(), needle);
      if (cmp < 0) {
        lo = mid + 1;
      } else if (cmp > 0) {
        hi = mid - 1;
      } else {
        return sa[mid];
      }
    }
    return string::npos;
  }
};

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  suffix_array sa("banana");
  vector<int> sarr = sa.get_sa(), lcp = sa.get_lcp();
  int sarr_expected[] = {5, 3, 1, 0, 4, 2};
  int lcp_expected[] = {1, 3, 0, 0, 2};
  assert(equal(sarr.begin(), sarr.end(), sarr_expected));
  assert(equal(lcp.begin(), lcp.end(), lcp_expected));
  assert(sa.find("ana") == 1);
  assert(sa.find("x") == string::npos);
  return 0;
}
\end{lstlisting}
\subsection{Suffix Array and LCP (Linear DC3)}
\begin{lstlisting}
/*

Given a string s, a suffix array is the array of the smallest starting positions
for the sorted suffices of s. That is, the i-th position of the suffix array
stores the starting position of the i-th lexicographically smallest suffix of s.
For examples, s = "cab" has the suffices "cab", "ab", and "b". When sorted, the
indices of the suffixes are "ab", "b", and "cab", so the suffix array (assuming
zero-based indices) is [1, 2, 0].

For a string s of length n the longest common prefix (LCP) array of length n - 1
stores the lengths of the longest common prefixes between all pairs of
lexicographically adjacent suffices in s. For example, "baa" has the sorted
suffices "a", "aa", and "baa", with an LCP array of [1, 0].

- suffix_array(s) constructs a suffix array from the given string s using the
  linear time DC3/skew algorithm by Karkkainen & Sanders (2003) with radix sort.
- get_sa() returns the constructed suffix array.
- get_lcp() returns the corresponding LCP array for the suffix array.
- find(needle) returns one position that needle occurs in s (not necessarily the
  first), or std::string::npos if it cannot be found. For a needle of length m,
  this implementation uses an O(m log n) binary search, but can be optimized to
  O(m + log n) by first computing the LCP-LR array using the LCP array.

Time Complexity:
- O(n) per call to the constructor, where n is the length of s.
- O(1) per call to get_sa().
- O(n) per call to get_lcp(), where n is the length of s.
- O(m log n) per call to find(needle), where m is the length of needle and n is
  the length of s.

Space Complexity:
- O(n) auxiliary for storage of the suffix and LCP arrays, where n is the length
  of s.
- O(n) auxiliary heap space for the constructor.
- O(1) auxiliary space for all other operations.

*/

#include <algorithm>
#include <string>
#include <utility>
#include <vector>
using std::string;

class suffix_array {
  static bool leq(int a1, int a2, int b1, int b2) {
    return (a1 < b1) || (a1 == b1 && a2 <= b2);
  }

  static bool leq(int a1, int a2, int a3, int b1, int b2, int b3) {
    return (a1 < b1) || (a1 == b1 && leq(a2, a3, b2, b3));
  }

  template<class It>
  static void radix_pass(It a, It b, It r, int n, int K) {
    std::vector<int> cnt(K + 1);
    for (int i = 0; i < n; i++) {
      cnt[r[a[i]]]++;
    }
    for (int i = 1; i <= K; i++) {
      cnt[i] += cnt[i - 1];
    }
    for (int i = n - 1; i >= 0; i--) {
      b[--cnt[r[a[i]]]] = a[i];
    }
  }

  template<class It>
  static void suffix_array_dc3(It s, It sa, int n, int K) {
    int n0 = (n + 2)/3, n1 = (n + 1)/3, n2 = n/3, n02 = n0 + n2;
    std::vector<int> s12(n02 + 3), sa12(n02 + 3), s0(n0), sa0(n0);
    s12[n02] = s12[n02 + 1] = s12[n02 + 2] = 0;
    sa12[n02] = sa12[n02 + 1] = sa12[n02 + 2] = 0;
    for (int i = 0, j = 0; i < n + n0 - n1; i++) {
      if (i % 3 != 0) {
        s12[j++] = i;
      }
    }
    radix_pass(s12.begin(), sa12.begin(), s + 2, n02, K);
    radix_pass(sa12.begin(), s12.begin(), s + 1, n02, K);
    radix_pass(s12.begin(), sa12.begin(), s, n02, K);
    int name = 0, c0 = -1, c1 = -1, c2 = -1;
    for (int i = 0; i < n02; i++) {
      if (s[sa12[i]] != c0 || s[sa12[i] + 1] != c1 || s[sa12[i] + 2] != c2) {
        name++;
        c0 = s[sa12[i]];
        c1 = s[sa12[i] + 1];
        c2 = s[sa12[i] + 2];
      }
      (sa12[i] % 3 == 1 ? s12[sa12[i]/3] : s12[sa12[i]/3 + n0]) = name;
    }
    if (name < n02) {
      suffix_array_dc3(s12.begin(), sa12.begin(), n02, name);
      for (int i = 0; i < n02; i++) {
        s12[sa12[i]] = i + 1;
      }
    } else {
      for (int i = 0; i < n02; i++) {
        sa12[s12[i] - 1] = i;
      }
    }
    for (int i = 0, j = 0; i < n02; i++) {
      if (sa12[i] < n0) {
        s0[j++] = 3*sa12[i];
      }
    }
    radix_pass(s0.begin(), sa0.begin(), s, n0, K);
    for (int p = 0, t = n0 - n1, k = 0; k < n; k++) {
      int i = (sa12[t] < n0) ? 3*sa12[t] + 1 : 3*(sa12[t] - n0) + 2, j = sa0[p];
      if (sa12[t] < n0 ? leq(s[i], s12[sa12[t] + n0],s[j], s12[j/3])
                       : leq(s[i], s[i + 1], s12[sa12[t] - n0 + 1], s[j],
                             s[j + 1], s12[j / 3 + n0])) {
        sa[k] = i;
        if (++t == n02) {
          for (k++; p < n0; p++, k++) {
            sa[k] = sa0[p];
          }
        }
      } else {
        sa[k] = j;
        if (++p == n0) {
          for (k++; t < n02; t++, k++) {
            sa[k] = (sa12[t] < n0) ? 3*sa12[t] + 1 : 3*(sa12[t] - n0) + 2;
          }
        }
      }
    }
  }

  string s;
  std::vector<int> sa;

 public:
  suffix_array(const string &s) : s(s), sa(s.size() + 1) {
    int n = s.size();
    std::vector<int> scopy(s.begin(), s.end());
    scopy.resize(n + 3);
    suffix_array_dc3(scopy.begin(), sa.begin(), n + 1, 255);
    sa.erase(sa.begin());
  }

  std::vector<int> get_sa() {
    return sa;
  }

  std::vector<int> get_lcp() {
    int n = s.size();
    std::vector<int> rank(n), lcp(n - 1);
    for (int i = 0; i < n; i++) {
      rank[sa[i]] = i;
    }
    for (int i = 0, k = 0; i < n; i++) {
      if (rank[i] < n - 1) {
        int j = sa[rank[i] + 1];
        while (std::max(i, j) + k < n && s[i + k] == s[j + k]) {
          k++;
        }
        lcp[rank[i]] = k;
        if (k > 0) {
          k--;
        }
      }
    }
    return lcp;
  }

  size_t find(const string &needle) {
    int lo = 0, hi = (int)s.size() - 1;
    while (lo <= hi) {
      int mid = lo + (hi - lo)/2;
      int cmp = s.compare(sa[mid], needle.size(), needle);
      if (cmp < 0) {
        lo = mid + 1;
      } else if (cmp > 0) {
        hi = mid - 1;
      } else {
        return sa[mid];
      }
    }
    return string::npos;
  }
};

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  suffix_array sa("banana");
  vector<int> sarr = sa.get_sa(), lcp = sa.get_lcp();
  int sarr_expected[] = {5, 3, 1, 0, 4, 2};
  int lcp_expected[] = {1, 3, 0, 0, 2};
  assert(equal(sarr.begin(), sarr.end(), sarr_expected));
  assert(equal(lcp.begin(), lcp.end(), lcp_expected));
  assert(sa.find("ana") == 1);
  assert(sa.find("x") == string::npos);
  return 0;
}
\end{lstlisting}

\section{String Data Structures}
\setcounter{section}{6}
\setcounter{subsection}{0}
\subsection{Trie}
\begin{lstlisting}
/*

Maintain a map of strings to values using an ordered tree data structure. Each
node corresponds to a character, and each inserted string corresponds to a path
from the root to a node that is flagged as a terminal node.

- trie() constructs an empty map.
- size() returns the size of the map.
- empty() returns whether the map is empty.
- insert(s, v) adds an entry with string key s and value v to the map, returning
  true if a new entry was added or false if the string already exists (in which
  case the map is unchanged and the old value associated with the string key is
  preserved).
- erase(s) removes the entry with string key s from the map, returning true if
  the removal was successful or false if the string to be removed was not found.
- find(s) returns a pointer to a const value associated with string key s, or
  NULL if the key was not found.
- walk(f) calls the function f(s, v) on each entry of the map, in
  lexicographically ascending order of the string keys.

Time Complexity:
- O(n) per call to insert(s, v), erase(s), and find(s), where n is the length of
  s. Note that there is a hidden factor of log(alphabet_size) which can be
  considered constant, since char can only take on 2^CHAR_BIT values. The
  implementation may be optimized by storing the children of nodes in an
  std::unordered_map in C++11 and later, or an array if a smaller alphabet size
  is guaranteed.
- O(l) per call to walk(), where l is the total length of string keys that are
  currently in the map.
- O(1) per call to all other operations.

Space Complexity:
- O(l) for storage of the trie, where l is the total length of string keys that
  are currently in the map.
- O(n) auxiliary stack space for construction, destruction, walk(), where n is
  the maximum length of any string that has been inserted so far.
- O(n) auxiliary stack space for erase(s), where n is the length of s.
- O(1) auxiliary for all other operations.

*/

#include <cstddef>
#include <map>
#include <string>
#include <utility>
using std::string;

template<class V>
class trie {
  struct node_t {
    V value;
    bool is_terminal;
    std::map<char, node_t*> children;

    node_t() : is_terminal(false) {}
  } *root;

  typedef typename std::map<char, node_t*>::iterator cit;

  static bool erase(node_t *n, const string &s, int i) {
    if (i == (int)s.size()) {
      if (!n->is_terminal) {
        return false;
      }
      n->is_terminal = false;
      return true;
    }
    cit it = n->children.find(s[i]);
    if (it == n->children.end() || !erase(it->second, s, i + 1)) {
      return false;
    }
    if (it->second->children.empty()) {
      delete it->second;
      n->children.erase(it);
    }
    return true;
  }

  template<class KVFunction>
  static void walk(node_t *n, string &s, KVFunction f) {
    if (n->is_terminal) {
      f(s, n->value);
    }
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      s += it->first;
      walk(it->second, s, f);
      s.pop_back();
    }
  }

  static void clean_up(node_t *n) {
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      clean_up(it->second);
    }
    delete n;
  }

  int num_terminals;

 public:
  trie() : root(new node_t()), num_terminals(0) {}

  ~trie() {
    clean_up(root);
  }

  int size() const {
    return num_terminals;
  }

  bool empty() const {
    return num_terminals == 0;
  }

  bool insert(const string &s, const V &v) {
    node_t *n = root;
    for (int i = 0; i < (int)s.size(); i++) {
      cit it = n->children.find(s[i]);
      if (it == n->children.end()) {
        n->children[s[i]] = new node_t();
      }
      n = n->children[s[i]];
    }
    if (n->is_terminal) {
      return false;
    }
    num_terminals++;
    n->is_terminal = true;
    n->value = v;
    return true;
  }

  bool erase(const string &s) {
    if (erase(root, s, 0)) {
      num_terminals--;
      return true;
    }
    return false;
  }

  const V* find(const string &s) const {
    node_t *n = root;
    for (int i = 0; i < (int)s.size(); i++) {
      cit it = n->children.find(s[i]);
      if (it == n->children.end()) {
        return NULL;
      }
      n = it->second;
    }
    return n->is_terminal ? &(n->value) : NULL;
  }

  template<class KVFunction>
  void walk(KVFunction f) const {
    string s = "";
    walk(root, s, f);
  }
};

/*** Example Usage and Output:

("", 0)
("a", 1)
("i", 6)
("in", 7)
("inn", 8)
("tea", 3)
("ted", 4)
("ten", 5)
("to", 2)

***/

#include <cassert>
#include <iostream>
using namespace std;

void print_entry(const string &k, int v) {
  cout << "(\"" << k << "\", " << v << ")" << endl;
}

int main() {
  string s[9] = {"", "a", "to", "tea", "ted", "ten", "i", "in", "inn"};
  trie<int> t;
  assert(t.empty());
  for (int i = 0; i < 9; i++) {
    assert(t.insert(s[i], i));
  }
  t.walk(print_entry);
  assert(!t.empty());
  assert(t.size() == 9);
  assert(!t.insert(s[0], 2));
  assert(t.size() == 9);
  assert(*t.find("") == 0);
  assert(*t.find("ten") == 5);
  assert(t.erase("tea"));
  assert(t.size() == 8);
  assert(t.find("tea") == NULL);
  assert(t.erase(""));
  assert(t.find("") == NULL);
  return 0;
}
\end{lstlisting}
\subsection{Radix Tree}
\begin{lstlisting}
/*

Maintain a map of strings to values using an ordered tree data structure. Each
node corresponds to a substring of an inserted string, and each inserted string
corresponds to a path from the root to a node that is flagged as a terminal
node. Contrary to a regular trie, a radix tree is more space efficient as it
combines chains of nodes with only a single child.

- radix_tree() constructs an empty map.
- size() returns the size of the map.
- empty() returns whether the map is empty.
- insert(s, v) adds an entry with string key s and value v to the map, returning
  true if a new entry was added or false if the string already exists (in which
  case the map is unchanged and the old value associated with the string key is
  preserved).
- erase(s) removes the entry with string key s from the map, returning true if
  the removal was successful or false if the string to be removed was not found.
- find(s) returns a pointer to a const value associated with string key s, or
  NULL if the key was not found.
- walk(f) calls the function f(s, v) on each entry of the map, in
  lexicographically ascending order of the string keys.

Time Complexity:
- O(n) per call to insert(s, v), erase(s), and find(s), where n is the length of
  s. Note that there is a hidden factor of log(n) due to map lookups, which can
  be considered constant amortized. The implementation may be optimized by
  storing the children of nodes in an std::unordered_map in C++11 and later, or
  an std::vector< pair<string, node_t*> >, since the only container operations
  required are iteration over the (key, child) pairs and inserting a new pair.
  Sticking with an (ordered) std::map, we can optimize all operations by using
  map.lower_bound(), a binary tree search for a child with a shared prefix,
  instead of iteration.
- O(l) per call to walk(), where l is the total length of string keys that are
  currently in the map.
- O(1) per call to all other operations.

Space Complexity:
- O(l) for storage of the radix tree, where l is the total length of string keys
  that are currently in the map.
- O(n) auxiliary stack space for construction, destruction, walk(), where n is
  the maximum length of any string that has been inserted so far.
- O(n) auxiliary stack space for erase(s), where n is the length of s.
- O(1) auxiliary for all other operations.

*/

#include <cstddef>
#include <map>
#include <string>
#include <utility>
using std::string;

template<class V>
class radix_tree {
  struct node_t {
    V value;
    bool is_terminal;
    std::map<string, node_t*> children;

    node_t(const V &value = V(), bool is_terminal = false)
        : value(value), is_terminal(is_terminal) {}
  } *root;

  typedef typename std::map<string, node_t*>::iterator cit;

  static int lcp_len(const string &s1, const string &s2, int s2start) {
    int i = 0;
    for (int j = s2start; i < (int)s1.size() && j < (int)s2.size(); i++, j++) {
      if (s1[i] != s2[j]) {
        break;
      }
    }
    return i;
  }

  static bool insert(node_t *n, const string &s, int i, const V &v) {
    if (i == (int)s.size()) {
      if (n->is_terminal) {
        return false;
      }
      n->is_terminal = true;
      return true;
    }
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      int len = lcp_len(it->first, s, i);
      if (len == 0) {
        continue;
      }
      if (len == (int)it->first.size()) {
        return insert(it->second, s, i + len, v);
      }
      string left = it->first.substr(0, len);
      string right = it->first.substr(len);
      node_t *tmp = new node_t();
      tmp->children[right] = it->second;
      n->children.erase(it);
      n->children[left] = tmp;
      if (len == (int)s.size() - i) {
        tmp->value = v;
        tmp->is_terminal = true;
        return true;
      }
      return insert(tmp, s, i + len, v);
    }
    n->children[s.substr(i)] = new node_t(v, true);
    return true;
  }

  static bool erase(node_t *n, const string &s, int i) {
    if (i == (int)s.size()) {
      if (!n->is_terminal) {
        return false;
      }
      n->is_terminal = false;
      return true;
    }
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      int len = lcp_len(it->first, s, i);
      if (len == 0) {
        continue;
      }
      node_t *child = it->second;
      if (!erase(child, s, i + len)) {
        return false;
      }
      if (child->children.empty()) {
        delete child;
        n->children.erase(it);
      } else if (child->children.size() == 1) {
        node_t *grandchild = child->children.begin()->second;
        if (!child->is_terminal) {
          string merged_key(it->first + child->children.begin()->first);
          child->value = grandchild->value;
          child->is_terminal = grandchild->is_terminal;
          child->children = grandchild->children;
          delete grandchild;
          n->children.erase(it);
          n->children[merged_key] = child;
        }
      }
      return true;
    }
    return false;
  }

  template<class KVFunction>
  static void walk(node_t *n, string &s, KVFunction f) {
    if (n->is_terminal) {
      f(s, n->value);
    }
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      s += it->first;
      walk(it->second, s, f);
      s.pop_back();
    }
  }

  static void clean_up(node_t *n) {
    for (cit it = n->children.begin(); it != n->children.end(); ++it) {
      clean_up(it->second);
    }
    delete n;
  }

  int num_terminals;

 public:
  radix_tree() : root(new node_t()), num_terminals(0) {}

  ~radix_tree() {
    clean_up(root);
  }

  int size() const {
    return num_terminals;
  }

  bool empty() const {
    return num_terminals == 0;
  }

  bool insert(const string &s, const V &v) {
    if (insert(root, s, 0, v)) {
      num_terminals++;
      return true;
    }
    return false;
  }

  bool erase(const string &s) {
    if (erase(root, s, 0)) {
      num_terminals--;
      return true;
    }
    return false;
  }

  const V* find(const string &s) const {
    node_t *n = root;
    int i = 0;
    while (i < (int)s.size()) {
      bool found = false;;
      for (cit it = n->children.begin(); it != n->children.end(); ++it) {
        if (it->first[0] == s[i]) {
          i += lcp_len(it->first, s, i);
          n = it->second;
          found = true;
          break;
        }
      }
      if (!found) {
        return NULL;
      }
    }
    return n->is_terminal ? &(n->value) : NULL;
  }

  template<class KVFunction>
  void walk(KVFunction f) const {
    string s = "";
    walk(root, s, f);
  }
};

/*** Example Usage and Output:

("", 0)
("a", 1)
("i", 6)
("in", 7)
("inn", 8)
("tea", 3)
("ted", 4)
("ten", 5)
("to", 2)

***/

#include <cassert>
#include <iostream>
using namespace std;

void print_entry(const string &k, int v) {
  cout << "(\"" << k << "\", " << v << ")" << endl;
}

int main() {
  string s[9] = {"", "a", "to", "tea", "ted", "ten", "i", "in", "inn"};
  radix_tree<int> t;
  assert(t.empty());
  for (int i = 0; i < 9; i++) {
    assert(t.insert(s[i], i));
  }
  t.walk(print_entry);
  assert(!t.empty());
  assert(t.size() == 9);
  assert(!t.insert(s[0], 2));
  assert(t.size() == 9);
  assert(t.find("") && *t.find("") == 0);
  assert(*t.find("ten") == 5);
  assert(t.erase("tea"));
  assert(t.size() == 8);
  assert(t.find("tea") == NULL);
  assert(t.erase(""));
  assert(t.find("") == NULL);
  return 0;
}
\end{lstlisting}
