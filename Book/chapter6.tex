\chapter{Geometry}

\section{Geometric Classes}
\setcounter{section}{1}
\setcounter{subsection}{0}
\subsection{Point}
\begin{lstlisting}
/*

A two-dimensional real-valued point class supporting epsilon comparisons.
Operations include element-wise arithmetic, norm, arg, dot product, cross
product, projection, rotation, and reflection. See also std::complex.

Time Complexity:
- O(1) per call to the constructor and all other operations.

Space Complexity:
- O(1) for storage of the point.
- O(1) auxiliary for all operations.

*/

#include <cmath>
#include <ostream>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)

struct point {
  double x, y;

  point() : x(0), y(0) {}
  point(double x, double y) : x(x), y(y) {}
  point(const point &p) : x(p.x), y(p.y) {}
  point(const std::pair<double, double> &p) : x(p.first), y(p.second) {}

  bool operator<(const point &p) const {
    return EQ(x, p.x) ? LT(y, p.y) : LT(x, p.x);
  }

  bool operator>(const point &p) const {
    return EQ(x, p.x) ? LT(p.y, y) : LT(p.x, x);
  }

  bool operator==(const point &p) const { return EQ(x, p.x) && EQ(y, p.y); }
  bool operator!=(const point &p) const { return !(*this == p); }
  bool operator<=(const point &p) const { return !(*this > p); }
  bool operator>=(const point &p) const { return !(*this < p); }
  point operator+(const point &p) const { return point(x + p.x, y + p.y); }
  point operator-(const point &p) const { return point(x - p.x, y - p.y); }
  point operator+(double v) const { return point(x + v, y + v); }
  point operator-(double v) const { return point(x - v, y - v); }
  point operator*(double v) const { return point(x * v, y * v); }
  point operator/(double v) const { return point(x / v, y / v); }
  point& operator+=(const point &p) { x += p.x; y += p.y; return *this; }
  point& operator-=(const point &p) { x -= p.x; y -= p.y; return *this; }
  point& operator+=(double v) { x += v; y += v; return *this; }
  point& operator-=(double v) { x -= v; y -= v; return *this; }
  point& operator*=(double v) { x *= v; y *= v; return *this; }
  point& operator/=(double v) { x /= v; y /= v; return *this; }
  friend point operator+(double v, const point &p) { return p + v; }
  friend point operator*(double v, const point &p) { return p * v; }

  double sqnorm() const { return x*x + y*y; }
  double norm() const { return sqrt(x*x + y*y); }
  double arg() const { return atan2(y, x); }
  double dot(const point &p) const { return x*p.x + y*p.y; }
  double cross(const point &p) const { return x*p.y - y*p.x; }
  double proj(const point &p) const { return dot(p) / p.norm(); }

  // Returns a proportional unit vector (p, q) = c(x, y) where p^2 + q^2 = 1.
  point normalize() const {
    return (EQ(x, 0) && EQ(y, 0)) ? point(0, 0) : (point(x, y) / norm());
  }

  // Returns (x, y) rotated 90 degrees clockwise about the origin.
  point rotate90() const { return point(-y, x); }

  // Returns (x, y) rotated t radians clockwise about the origin.
  point rotateCW(double t) const {
    return point(x*cos(t) + y*sin(t), y*cos(t) - x*sin(t));
  }

  // Returns (x, y) rotated t radians counter-clockwise about the origin.
  point rotateCCW(double t) const {
    return point(x*cos(t) - y*sin(t), x*sin(t) + y*cos(t));
  }

  // Returns (x, y) rotated t radians clockwise about point p.
  point rotateCW(const point &p, double t) const {
    return (*this - p).rotateCW(t) + p;
  }

  // Returns (x, y) rotated t radians counter-clockwise about the point p.
  point rotateCCW(const point &p, double t) const {
    return (*this - p).rotateCCW(t) + p;
  }

  // Returns (x, y) reflected across point p.
  point reflect(const point &p) const {
    return point(2*p.x - x, 2*p.y - y);
  }

  // Returns (x, y) reflected across the line containing points p and q.
  point reflect(const point &p, const point &q) const {
    if (p == q) {
      return reflect(p);
    }
    point r(*this - p), s = q - p;
    r = point(r.x*s.x + r.y*s.y, r.x*s.y - r.y*s.x) / s.sqnorm();
    r = point(r.x*s.x - r.y*s.y, r.x*s.y + r.y*s.x) + p;
    return r;
  }

  friend double sqnorm(const point &p) { return p.sqnorm(); }
  friend double norm(const point &p) { return p.norm(); }
  friend double arg(const point &p) { return p.arg(); }
  friend double dot(const point &p, const point &q) { return p.dot(q); }
  friend double cross(const point &p, const point &q) { return p.cross(q); }
  friend double proj(const point &p, const point &q) { return p.proj(q); }
  friend point normalize(const point &p) { return p.normalize(); }
  friend point rotate90(const point &p) { return p.rotate90(); }

  friend point rotateCW(const point &p, double t) {
    return p.rotateCW(t);
  }

  friend point rotateCCW(const point &p, double t) {
    return p.rotateCCW(t);
  }

  friend point rotateCW(const point &p, const point &q, double t) {
    return p.rotateCW(q, t);
  }

  friend point rotateCCW(const point &p, const point &q, double t) {
    return p.rotateCCW(q, t);
  }

  friend point reflect(const point &p, const point &q) {
    return p.reflect(q);
  }

  friend point reflect(const point &p, const point &a, const point &b) {
    return p.reflect(a, b);
  }

  friend std::ostream& operator<<(std::ostream &out, const point &p) {
    return out << "(" << (fabs(p.x) < EPS ? 0 : p.x) << ","
                      << (fabs(p.y) < EPS ? 0 : p.y) << ")";
  }
};

/*** Example Usage ***/

#include <cassert>
#define pt point

const double PI = acos(-1.0);

int main() {
  pt p(-10, 3), q;
  assert(pt(-18, 29) == p + pt(-3, 9)*6 / 2 - pt(-1, 1));
  assert(EQ(109, p.sqnorm()));
  assert(EQ(10.44030650891, p.norm()));
  assert(EQ(2.850135859112, p.arg()));
  assert(EQ(0, p.dot(pt(3, 10))));
  assert(EQ(0, p.cross(pt(10, -3))));
  assert(EQ(10, p.proj(pt(-10, 0))));
  assert(EQ(1, p.normalize().norm()));
  assert(pt(-3, -10) == p.rotate90());
  assert(pt(3, 12) == p.rotateCW(pt(1, 1), PI / 2));
  assert(pt(1, -10) == p.rotateCCW(pt(2, 2), PI / 2));
  assert(pt(10, -3) == p.reflect(pt(0, 0)));
  assert(pt(-10, -3) == p.reflect(pt(-2, 0), pt(5, 0)));
  return 0;
}
\end{lstlisting}
\subsection{Line}
\begin{lstlisting}
/*

A straight line in two dimensions supporting epsilon comparisons. The line is
represented by the form a*x + b*y + c = 0, where the coefficients are normalized
so that b is always 1 except for when the line is vertical, in which case b = 0.
Operations include checking if the line is horizontal or vertical, finding the
slope, evaluating y at some x (and vice versa), checking if a point falls on the
line, checking if another line is parallel or perpendicular, and finding the
parallel or perpendicular line through a point.

Time Complexity:
- O(1) per call to the constructor and all other operations.

Space Complexity:
- O(1) for storage of the line.
- O(1) auxiliary for all operations.

*/

#include <cmath>
#include <limits>
#include <ostream>

const double EPS = 1e-9;
const double M_NAN = std::numeric_limits<double>::quiet_NaN();

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)

struct line {
  double a, b, c;

  line() : a(0), b(0), c(0) {}  // Invalid or uninitialized line.

  line(double a, double b, double c) {
    if (!EQ(b, 0)) {
      this->a = a / b;
      this->c = c / b;
      this->b = 1;
    } else {
      this->c = c / a;
      this->a = 1;
      this->b = 0;
    }
  }

  template<class Point>
  line(double slope, const Point &p) {
    a = -slope;
    b = 1;
    c = slope * p.x - p.y;
  }

  template<class Point>
  line(const Point &p, const Point &q) : a(0), b(0), c(0) {
    if (EQ(p.x, q.x)) {
      if (NE(p.y, q.y)) {  // Vertical line.
        a = 1;
        b = 0;
        c = -p.x;
      }  // Else, invalid line.
    } else {
      a = -(p.y - q.y) / (p.x - q.x);
      b = 1;
      c = -(a*p.x) - (b*p.y);
    }
  }

  bool operator==(const line &l) const {
    return EQ(a, l.a) && EQ(b, l.b) && EQ(c, l.c);
  }

  bool operator!=(const line &l) const {
    return !(*this == l);
  }

  // Returns whether the line is initialized and normalized.
  bool valid() const {
    if (EQ(a, 0)) {
      return !EQ(b, 0);
    }
    return EQ(b, 1) || (EQ(b, 0) && EQ(a, 1));
  }

  bool horizontal() const { return valid() && EQ(a, 0); }
  bool vertical() const { return valid() && EQ(b, 0); }
  double slope() const { return (!valid() || EQ(b, 0)) ? M_NAN : -a; }

  // Solve for x at a given y. If the line is horizontal, then either -INF, INF,
  // or NAN is returned based on whether y is below, above, or on the line.
  double x(double y) const {
    if (!valid() || EQ(a, 0)) {
      return M_NAN;  // Invalid or horizontal line.
    }
    return (-c - b*y) / a;
  }

  // Solve for y at a given x. If the line is vertical, then either -INF, INF,
  // or NAN is returned based on whether x is left of, right of, or on the line.
  double y(double x) const {
    if (!valid() || EQ(b, 0)) {
      return M_NAN;  // Invalid or vertical line.
    }
    return (-c - a*x) / b;
  }

  template<class Point>
  bool contains(const Point &p) const { return EQ(a*p.x + b*p.y + c, 0); }

  bool is_parallel(const line &l) const { return EQ(a, l.a) && EQ(b, l.b); }
  bool is_perpendicular(const line &l) const { return EQ(-a*l.a, b*l.b); }

  // Return the parallel line passing through point p.
  template<class Point>
  line parallel(const Point &p) const {
    return line(a, b, -a*p.x - b*p.y);
  }

  // Return the perpendicular line passing through point p.
  template<class Point>
  line perpendicular(const Point &p) const {
    return line(-b, a, b*p.x - a*p.y);
  }

  friend std::ostream& operator<<(std::ostream &out, const line &l) {
    return out << (fabs(l.a) < EPS ? 0 : l.a) << "x" << std::showpos
               << (fabs(l.b) < EPS ? 0 : l.b) << "y"
               << (fabs(l.c) < EPS ? 0 : l.c) << "=0" << std::noshowpos;
  }
};

/*** Example Usage ***/

#include <cassert>

struct point {
  double x, y;
  point(double x, double y) : x(x), y(y) {}
};

int main() {
  line l(2, -5, -8);
  line para = line(2, -5, -8).parallel(point(-6, -2));
  line perp = line(2, -5, -8).perpendicular(point(-6, -2));
  assert(l.is_parallel(para) && l.is_perpendicular(perp));
  assert(l.slope() == 0.4);
  assert(para == line(-0.4, 1, -0.4));  // -0.4x + y - 0.4 = 0.
  assert(perp == line(2.5, 1, 17));  // 2.5x + y + 17 = 0.
  return 0;
}
\end{lstlisting}
\subsection{Circle}
\begin{lstlisting}
/*

A circle in two dimensions supporting epsilon comparisons. The circle centered
at (h, k) is represented by the relation (x - h)^2 + (y - k)^2 = r^2, where the
radius r is normalized to a non-negative number. Operations include constructing
a circle from a line segment, constructing a circumcircle, checking if a point
falls inside the circle or on its edge, and constructing an incircle.

Time Complexity:
- O(1) per call to the constructors and all other operations.

Space Complexity:
- O(1) for storage of the circle.
- O(1) auxiliary for all operations.

*/

#include <cmath>
#include <ostream>
#include <stdexcept>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define LT(a, b) ((a) < (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }

struct circle {
  double h, k, r;

  circle() : h(0), k(0), r(0) {}
  circle(double r) : h(0), k(0), r(fabs(r)) {}
  circle(const point &o, double r) : h(o.x), k(o.y), r(fabs(r)) {}
  circle(double h, double k, double r) : h(h), k(k), r(fabs(r)) {}

  // Circle with the line segment ab as a diameter.
  circle(const point &a, const point &b) {
    h = (a.x + b.x)/2.0;
    k = (a.y + b.y)/2.0;
    r = norm(point(a.x - h, a.y - k));
  }

  // Circumcircle of three points.
  circle(const point &a, const point &b, const point &c) {
    double an = sqnorm(point(b.x - c.x, b.y - c.y));
    double bn = sqnorm(point(a.x - c.x, a.y - c.y));
    double cn = sqnorm(point(a.x - b.x, a.y - b.y));
    double wa = an*(bn + cn - an);
    double wb = bn*(an + cn - bn);
    double wc = cn*(an + bn - cn);
    double w = wa + wb + wc;
    if (EQ(w, 0)) {
      throw std::runtime_error("No circumcircle from collinear points.");
    }
    h = (wa*a.x + wb*b.x + wc*c.x)/w;
    k = (wa*a.y + wb*b.y + wc*c.y)/w;
    r = norm(point(a.x - h, a.y - k));
  }

  // Circle of radius r that contains points a and b. In the general case, there
  // will be two possible circles and only one is chosen arbitrarily. However if
  // the diameter is equal to dist(a, b) = 2*r, then there is only one possible
  // center. If points a and b are identical, then there are infinite circles.
  // If the points are too far away relative to the radius, then there is no
  // possible circle. In the latter two cases, an exception is thrown.
  circle(const point &a, const point &b, double r) : r(fabs(r)) {
    if (LE(r, 0) && a == b) {  // Circle with zero area.
      h = a.x;
      k = a.y;
      return;
    }
    double d = norm(point(b.x - a.x, b.y - a.y));
    if (EQ(d, 0)) {
      throw std::runtime_error("Identical points, infinite circles.");
    }
    if (LT(r*2.0, d)) {
      throw std::runtime_error("Points too far away to make circle.");
    }
    double v = sqrt(r*r - d*d/4.0) / d;
    point m((a.x + b.x)/2.0, (a.y + b.y)/2.0);
    h = m.x + v*(a.y - b.y);
    k = m.y + v*(b.x - a.x);
    // The other answer is (h, k) = (m.x - v*(a.y - b.y), m.y - v*(b.x - a.x)).
  }

  bool operator==(const circle &c) const {
    return EQ(h, c.h) && EQ(k, c.k) && EQ(r, c.r);
  }

  bool operator!=(const circle &c) const {
    return !(*this == c);
  }

  point center() const { return point(h, k); }

  bool contains(const point &p) const {
    return LE(sqnorm(point(p.x - h, p.y - k)), r*r);
  }

  bool on_edge(const point &p) const {
    return EQ(sqnorm(point(p.x - h, p.y - k)), r*r);
  }

  friend std::ostream& operator<<(std::ostream &out, const circle &c) {
    return out << std::showpos << "(x" << -(fabs(c.h) < EPS ? 0 : c.h) << ")^2+"
                               << "(y" << -(fabs(c.k) < EPS ? 0 : c.k) << ")^2"
               << std::noshowpos << "=" << (fabs(c.r) < EPS ? 0 : c.r*c.r);
  }
};

// Returns the circle inscribed inside the triangle abc.
circle incircle(const point &a, const point &b, const point &c) {
  double al = norm(point(b.x - c.x, b.y - c.y));
  double bl = norm(point(a.x - c.x, a.y - c.y));
  double cl = norm(point(a.x - b.x, a.y - b.y));
  double l = al + bl + cl;
  point p(a.x - c.x, a.y - c.y), q(b.x - c.x, b.y - c.y);
  return EQ(l, 0) ? circle(a.x, a.y, 0)
                  : circle((al*a.x + bl*b.x + cl*c.x) / l,
                           (al*a.y + bl*b.y + cl*c.y) / l,
                           fabs(p.x*q.y - p.y*q.x) / l);
}

/*** Example Usage ***/

#include <cassert>

int main() {
  circle c(-2, 5, sqrt(10));
  assert(c == circle(point(-2, 5), sqrt(10)));
  assert(c == circle(point(1, 6), point(-5, 4)));
  assert(c == circle(point(-3, 2), point(-3, 8), point(-1, 8)));
  assert(c == incircle(point(-12, 5), point(3, 0), point(0, 9)));
  assert(c.contains(point(-2, 8)) && !c.contains(point(-2, 9)));
  assert(c.on_edge(point(-1, 2)) && !c.on_edge(point(-1.01, 2)));
  return 0;
}
\end{lstlisting}
\subsection{Triangle}
\begin{lstlisting}
/*

Common triangle calculations in two dimensions.

- triangle_area(a, b, c) returns the area of the triangle abc.
- triangle_area_sides(s1, s2, s3) returns the area of a triangle with side
  lengths s1, s2, and s3. The given lengths must be non-negative and form a
  valid triangle.
- trinagle_area_medians(m1, m2, m3) returns the area of a triangle with medians
  of lengths m1, m2, and m3. The median of a triangle is a line segment joining
  a vertex to the midpoint of the opposing edge.
- triangle_area_altitudes(h1, h2, h3) returns the area of a triangle with
  altitudes h1, h2, and h3. An altitude of a triangle is the shortest line
  between a vertex and the infinite line that is extended from its opposite
  edge.
- same_side(p1, p2, a, b) returns whether points p1 and p2 lie on the same side
  of the line containing points a and b. If one or both points lie exactly on
  the line, then the result will depend on the setting of EDGE_IS_SAME_SIDE.
- point_in_triangle(p, a, b, c) returns whether point p lies within the triangle
  abc. If the point lies on or close to an edge (by roughly EPS), then the
  result will depend on the setting of EDGE_IS_SAME_SIDE in the function above.

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GT(a, b) ((a) > (b) + EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double cross(const point &a, const point &b) { return a.x*b.y - a.y*b.x; }

double triangle_area(const point &a, const point &b, const point &c) {
  point ac(a.x - c.x, a.y - c.y), bc(b.x - c.x, b.y - c.y);
  return fabs(cross(ac, bc)) / 2.0;
}

double triangle_area_sides(double s1, double s2, double s3) {
  double s = (s1 + s2 + s3) / 2.0;
  return sqrt(s*(s - s1)*(s - s2)*(s - s3));
}

double triangle_area_medians(double m1, double m2, double m3) {
  return 4.0*triangle_area_sides(m1, m2, m3) / 3.0;
}

double triangle_area_altitudes(double h1, double h2, double h3) {
  if (EQ(h1, 0) || EQ(h2, 0) || EQ(h3, 0)) {
    return 0;
  }
  double x = h1*h1, y = h2*h2, z = h3*h3;
  double v = 2.0/(x*y) + 2.0/(x*z) + 2.0/(y*z);
  return 1.0/sqrt(v - 1.0/(x*x) - 1.0/(y*y) - 1.0/(z*z));
}

bool same_side(const point &p1, const point &p2, const point &a,
               const point &b) {
  static const bool EDGE_IS_SAME_SIDE = true;
  point ab(b.x - a.x, b.y - a.y);
  point p1a(p1.x - a.x, p1.y - a.y), p2a(p2.x - a.x, p2.y - a.y);
  double c1 = cross(ab, p1a), c2 = cross(ab, p2a);
  return EDGE_IS_SAME_SIDE ? GE(c1*c2, 0) : GT(c1*c2, 0);
}

bool point_in_triangle(const point &p, const point &a, const point &b,
                       const point &c) {
  return same_side(p, a, b, c) &&
         same_side(p, b, a, c) &&
         same_side(p, c, a, b);
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(EQ(6, triangle_area(point(0, -1), point(4, -1), point(0, -4))));
  assert(EQ(6, triangle_area_sides(3, 4, 5)));
  assert(EQ(6, triangle_area_medians(3.605551275, 2.5, 4.272001873)));
  assert(EQ(6, triangle_area_altitudes(3, 4, 2.4)));

  assert(point_in_triangle(point(0, 0),
                           point(-1, 0), point(0, -2), point(4, 0)));
  assert(!point_in_triangle(point(0, 1),
                            point(-1, 0), point(0, -2), point(4, 0)));
  assert(point_in_triangle(point(-2.44, 0.82),
                           point(-1, 0), point(-3, 1), point(4, 0)));
  assert(!point_in_triangle(point(-2.44, 0.7),
                            point(-1, 0), point(-3, 1), point(4, 0)));
  return 0;
}
\end{lstlisting}
\subsection{Rectangle}
\begin{lstlisting}
/*

Common rectangle calculations in two dimensions.

- rectangle_area(a, b) returns the area of a rectangle with opposing vertices a
  and b.
- point_in_rectangle(p, x, y, w, h) returns whether point p lies within the
  rectangle defined by a vertex at v (x, y), a width of w, and a height of h.
  Note that negative widths and heights are supported. If the point lies on or
  close to an edge (by roughly EPS), then the result will depend on the setting
  of EDGE_IS_INSIDE.
- point_in_rectangle(p, a, b) returns whether point p lies within the rectangle
  with opposing vertices a and b. If the point lies on or close to an edge (by
  roughly EPS), then the result will depend on the setting of EDGE_IS_INSIDE.
- rectangle_intersection(a1, b1, a2, b2, &p, &q) determines the intersection
  region of the rectangle with opposing vertices a1 and b1 and the rectangle
  with opposing vertices a2 and b2. Returns -1 if the rectangles are completely
  disjoint, 0 if the rectangles partially intersect, 1 if the first rectangle is
  completely inside the second, and 2 if the second rectangle is completely
  inside the first. If there is an intersection, the opposing vertices of the
  intersection rectangle will be stored into pointers p and q if they are not
  NULL. If the intersection is a single point or line segment, then the result
  will depend on the setting of EDGE_IS_INSIDE within point_in_rectangle().

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <cstddef>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GT(a, b) ((a) > (b) + EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double rectangle_area(const point &a, const point &b) {
  return fabs((a.x - b.x)*(a.y - b.y));
}

bool point_in_rectangle(const point &p, const point &v, double w, double h) {
  static const bool EDGE_IS_INSIDE = true;
  if (w < 0) {
    return point_in_rectangle(p, point(v.x + w, v.y), -w, h);
  }
  if (h < 0) {
    return point_in_rectangle(p, point(v.x, v.y + h), w, -h);
  }
  return EDGE_IS_INSIDE
      ? (GE(p.x, v.x) && LE(p.x, v.x + w) && GE(p.y, v.y) && LE(p.y, v.y + h))
      : (GT(p.x, v.x) && LT(p.x, v.x + w) && GT(p.y, v.y) && LT(p.y, v.y + h));
}

bool point_in_rectangle(const point &p, const point &a, const point &b) {
  double xl = std::min(a.x, b.x), yl = std::min(a.y, b.y);
  double xh = std::max(a.x, b.x), yh = std::max(a.y, b.y);
  return point_in_rectangle(p, point(xl, yl), xh - xl, yh - yl);
}

int rectangle_intersection(const point &a1, const point &b1, const point &a2,
                           const point &b2, point *p = NULL, point *q = NULL) {
  bool a1in2 = point_in_rectangle(a1, a2, b2);
  bool b1in2 = point_in_rectangle(b1, a2, b2);
  if (a1in2 && b1in2) {
    if (p != NULL && q != NULL) {
      *p = std::min(a1, b1);
      *q = std::max(a1, b1);
    }
    return 1;  // Rectangle 1 completely inside 2.
  }
  if (!a1in2 && !b1in2) {
    if (point_in_rectangle(a2, a1, b1)) {
      if (p != NULL && q != NULL) {
        *p = std::min(a2, b2);
        *q = std::max(a2, b2);
      }
      return 2;  // Rectangle 2 completely inside 1.
    }
    return -1;  // Completely disjoint.
  }
  if (p != NULL && q != NULL) {
    if (a1in2) {
      *p = a1;
      *q = (a1 < b1) ? std::max(a2, b2) : std::min(a2, b2);
    } else {
      *p = b1;
      *q = (b1 < a1) ? std::max(a2, b2) : std::min(a2, b2);
    }
    if (*p > *q) {
      std::swap(p, q);
    }
  }
  return 0;
}

/*** Example Usage ***/

#include <cassert>

bool EQP(const point &a, const point &b) {
  return EQ(a.x, b.x) && EQ(a.y, b.y);
}

int main() {
  assert(EQ(20, rectangle_area(point(1, 1), point(5, 6))));

  assert(point_in_rectangle(point(0, -1), point(0, -3), 3, 2));
  assert(point_in_rectangle(point(2, -2), point(3, -3), -3, 2));
  assert(!point_in_rectangle(point(0, 0), point(3, -1), -3, -2));
  assert(point_in_rectangle(point(2, -2), point(3, -3), point(0, -1)));
  assert(!point_in_rectangle(point(-1, -2), point(3, -3), point(0, -1)));

  point p, q;
  assert(-1 == rectangle_intersection(point(0, 0), point(1, 1),
                                      point(2, 2), point(3, 3)));
  assert(0 == rectangle_intersection(point(1, 1), point(7, 7),
                                     point(5, 5), point(0, 0), &p, &q));
  assert(EQP(p, point(1, 1)) && EQP(q, point(5, 5)));
  assert(1 == rectangle_intersection(point(1, 1), point(0, 0),
                                     point(0, 0), point(1, 10), &p, &q));
  assert(EQP(p, point(0, 0)) && EQP(q, point(1, 1)));
  assert(2 == rectangle_intersection(point(0, 5), point(5, 7),
                                     point(1, 6), point(2, 5), &p, &q));
  assert(EQP(p, point(1, 6)) && EQP(q, point(2, 5)));

  return 0;
}
\end{lstlisting}

\section{Elementary Geometric Calculations}
\setcounter{section}{2}
\setcounter{subsection}{0}
\subsection{Angles}
\begin{lstlisting}
/*

Angle calculations in two dimensions. The constants DEG and RAD may be used as
multipliers to convert between degrees and radians. For example, if t is a value
in radians, then t*DEG is the equivalent angle in degrees.

- reduce_deg(t) takes an angle t degrees and returns an equivalent angle in the
  range [0, 360) degrees. E.g. -630 becomes 90.
- reduce_rad(t) takes an angle t radians and returns an equivalent angle in the
  range [0, 360) radians. E.g. 720.5 becomes 0.5.
- polar_point(r, t) returns a two-dimensional Cartesian point given radius r and
  angle t radians in polar coordinates (see std::polar()).
- polar_angle(p) returns the angle in radians of the line segment from (0, 0) to
  point p, relative counterclockwise to the positive x-axis.
- angle(a, o, b) returns the smallest angle in radians formed by the points a,
  o, b with vertex at point o.
- angle_between(a, b) returns the angle in radians of segment from point a to
  point b, relative counterclockwise to the positive x-axis.
- angle between(a1, b1, a2, b2) returns the smaller angle in radians between
  two lines a1*x + b1*y + c1 = 0 and a2*x + b2*y + c2 = 0, limited to [0, PI/2].
- cross(a, b, o) returns the magnitude (Euclidean norm) of the three-dimensional
  cross product between points a and b where the z-component is implicitly zero
  and the origin is implicitly shifted to point o. This operation is also equal
  to double the signed area of the triangle from these three points.
- turn(a, o, b) returns -1 if the path a->o->b forms a left turn on the plane, 0
  if the path forms a straight line segment, or 1 if it forms a right turn.

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <cmath>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GT(a, b) ((a) > (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }

const double PI = acos(-1.0), DEG = PI/180, RAD = 180/PI;

double reduce_deg(double t) {
  if (t < -360) {
    return reduce_deg(fmod(t, 360));
  }
  if (t < 0) {
    return t + 360;
  }
  return (t >= 360) ? fmod(t, 360) : t;
}

double reduce_rad(double t) {
  if (t < -2*PI) {
    return reduce_rad(fmod(t, 2*PI));
  }
  if (t < 0) {
    return t + 2*PI;
  }
  return (t >= 2*PI) ? fmod(t, 2*PI) : t;
}

point polar_point(double r, double t) {
  return point(r*cos(t), r*sin(t));
}

double polar_angle(const point &p) {
  double t = atan2(p.y, p.x);
  return (t < 0) ? (t + 2*PI) : t;
}

double angle(const point & a, const point & o, const point & b) {
  point u(o.x - a.x, o.y - a.y), v(o.x - b.x, o.y - b.y);
  return acos((u.x*v.x + u.y*v.y) / (norm(u)*norm(v)));
}

double angle_between(const point &a, const point &b) {
  double t = atan2(a.x*b.y - a.y*b.x, a.x*b.x + a.y*b.y);
  return (t < 0) ? (t + 2*PI) : t;
}

double angle_between(const double &a1, const double &b1,
                     const double &a2, const double &b2) {
  double t = atan2(a1*b2 - a2*b1, a1*a2 + b1*b2);
  if (t < 0) {
    t += PI;
  }
  return GT(t, PI / 2) ? (PI - t) : t;
}

double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

int turn(const point &a, const point &o, const point &b) {
  double c = cross(a, b, o);
  return LT(c, 0) ? -1 : (GT(c, 0) ? 1 : 0);
}

/*** Example Usage ***/

#include <cassert>

bool EQP(const point &a, const point &b) {
  return EQ(a.x, b.x) && EQ(a.y, b.y);
}

int main() {
  assert(EQ(123, reduce_deg(-8*360 + 123)));
  assert(EQ(1.2345, reduce_rad(2*PI*8 + 1.2345)));
  assert(EQP(polar_point(4, PI), point(-4, 0)));
  assert(EQP(polar_point(4, -PI/2), point(0, -4)));
  assert(EQ(45, polar_angle(point(5, 5))*RAD));
  assert(EQ(135*DEG, polar_angle(point(-4, 4))));
  assert(EQ(90*DEG, angle(point(5, 0), point(0, 5), point(-5, 0))));
  assert(EQ(225*DEG, angle_between(point(0, 5), point(5, -5))));
  assert(-1 == cross(point(0, 1), point(1, 0), point(0, 0)));
  assert(1 == turn(point(0, 1), point(0, 0), point(-5, -5)));
  return 0;
}
\end{lstlisting}
\subsection{Distances}
\begin{lstlisting}
/*

Distance calculations in two dimensions for points, lines, and line segments.

- dist(a, b) and sqdist(a, b) respectively return the distance and squared
  distance between points a and b.
- line_dist(p, a, b, c) returns the distance from point p to the line
  a*x + b*y + c = 0. If the line is invalid (i.e. a = b = 0), then -INF, INF,
  or NaN is returned based on the sign of c.
- line_dist(p, a, b) returns the distance from point p to the infinite line
  containing points a and b. If the line is invalid (i.e. a = b), then the
  distance from p to the single point is returned.
- line_dist(a1, b1, c1, a2, b2, c2) returns the distance between two lines. If
  the lines are non-parallel then the distance is considered to be 0. Otherwise,
  the distance is considered to be the perpendicular distance from any point on
  one line to the other line.
- seg_dist(p, a, b) returns the distance from point p to the line segment ab.
- seg_dist(a, b, c, d) returns the minimum distance from any point on the line
  segment ab to any point on the line segment cd. This is 0 if the segments
  touch or intersect.

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }
double dot(const point &a, const point &b) { return a.x*b.x + a.y*b.y; }
double cross(const point &a, const point &b) { return a.x*b.y - a.y*b.x; }

double dist(const point &a, const point &b) {
  return norm(point(b.x - a.x, b.y - a.y));
}

double sqdist(const point &a, const point &b) {
  return sqnorm(point(b.x - a.x, b.y - a.y));
}

double line_dist(const point &p, double a, double b, double c) {
  return fabs(a*p.x + b*p.y + c) / sqrt(a*a + b*b);
}

double line_dist(const point &p, const point &a, const point &b) {
  if (EQ(a.x, b.x) && EQ(a.y, b.y)) {
    return dist(p, a);
  }
  double u = ((p.x - a.x)*(b.x - a.x) + (p.y - a.y)*(b.y - a.y)) / sqdist(a, b);
  return norm(point(a.x + u*(b.x - a.x) - p.x, a.y + u*(b.y - a.y) - p.y));
}

double line_dist(double a1, double b1, double c1,
                 double a2, double b2, double c2) {
  if (EQ(a1*b2, a2*b1)) {
    double factor = EQ(b1, 0) ? (a1 / a2) : (b1 / b2);
    return EQ(c1, c2*factor) ? 0
                             : fabs(c2*factor - c1) / sqrt(a1*a1 + b1*b1);
  }
  return 0;
}

double seg_dist(const point &p, const point &a, const point &b) {
  if (EQ(a.x, b.x) && EQ(a.y, b.y)) {
    return dist(p, a);
  }
  point ab(b.x - a.x, b.y - a.y), ap(p.x - a.x, p.y - a.y);
  double n = sqnorm(ab), d = dot(ab, ap);
  if (LE(d, 0) || EQ(n, 0)) {
    return norm(ap);
  }
  return GE(d, n) ? norm(point(ap.x - ab.x, ap.y - ab.y))
                  : norm(point(ap.x - ab.x*(d / n), ap.y - ab.y*(d / n)));
}

double seg_dist(const point &a, const point &b,
                const point &c, const point &d) {
  point ab(b.x - a.x, b.y - a.y);
  point ac(c.x - a.x, c.y - a.y);
  point cd(d.x - c.x, d.y - c.y);
  double c1 = cross(ab, cd), c2 = cross(ac, ab);
  if (EQ(c1, 0) && EQ(c2, 0)) {
    double t0 = dot(ac, ab) / norm(ab), t1 = t0 + dot(cd, ab) / norm(ab);
    if (LE(std::min(t0, t1), 1) && LE(0, std::max(t0, t1))) {
      return 0;
    }
  } else {
    double t = cross(ac, cd) / c1, u = c2 / c1;
    if (!EQ(c1, 0) && LE(0, t) && LE(t, 1) && LE(0, u) && LE(u, 1)) {
      return 0;
    }
  }
  return std::min(std::min(seg_dist(a, c, d), seg_dist(b, c, d)),
                  std::min(seg_dist(c, a, b), seg_dist(d, a, b)));
}

point closest_point(const point &a, const point &b, const point &p) {
  if (EQ(a.x, b.x) && EQ(a.y, b.y)) {
    return a;
  }
  point ap(p.x - a.x, p.y - a.y), ab(b.x - a.x, b.y - a.y);
  double t = dot(ap, ab) / sqnorm(ab);
  return (t <= 0) ? a : ((t >= 1) ? b : point(a.x + t*ab.x, a.y + t*ab.y));
}

/*** Example Usage ***/

#include <cassert>

int main() {
  assert(EQ(5, dist(point(-1, -1), point(2, 3))));
  assert(EQ(25, sqdist(point(-1, -1), point(2, 3))));
  assert(EQ(1.2, line_dist(point(2, 1), -4, 3, -1)));
  assert(EQ(0.8, line_dist(point(3, 3), point(-1, -1), point(2, 3))));
  assert(EQ(1.2, line_dist(point(2, 1), point(-1, -1), point(2, 3))));
  assert(EQ(0, line_dist(-4, 3, -1, 8, 6, 2)));
  assert(EQ(0.8, line_dist(-4, 3, -1, -8, 6, -10)));
  assert(EQ(1.0, seg_dist(point(3, 3), point(-1, -1), point(2, 3))));
  assert(EQ(1.2, seg_dist(point(2, 1), point(-1, -1), point(2, 3))));
  assert(EQ(0, seg_dist(point(0, 2), point(3, 3), point(-1, -1), point(2, 3))));
  assert(EQ(0.6,
            seg_dist(point(-1, 0), point(-2, 2), point(-1, -1), point(2, 3))));
  return 0;
}
\end{lstlisting}
\subsection{Line Intersection}
\begin{lstlisting}
/*

Intersection and closest point calculations in two dimensions for straight lines
and line segments.

- line_intersection(a1, b1, c1, a2, b2, c2, &p) determines whether the lines
  a1*x + b1*y + c1 = 0 and a2*x + b2*x + c2 = 0 intersects, returning -1 if
  there is no intersection because the lines are parallel, 0 if there is exactly
  one intersection (in which case the intersection point is stored into pointer
  p if it's not NULL), or 1 if there are infinite intersections because the
  lines are identical.
- line_intersection(p1, p2, p3, p4, &p) determines whether the infinite lines
  (not segments) through points p1, p2 and through points p3 and p4 intersect,
  returning -1 if there is no intersection because the lines are parallel, 0 if
  there is exactly one intersection (in which case the intersection point is
  stored into pointer p if it's not NULL), or 1 if there are infinite
  intersections because the lines are identical.
- seg_intersection(a, b, c, d, &p, &q) determines whether the line segment ab
  intersects the line segment cd, returning -1 if the segments do not intersect,
  0 if there is exactly one intersection point (in which case it is stored into
  pointer p if it's not NULL), or 1 if the intersection is another line segment
  (in which case the two endpoints are stored into pointers p and q if they are
  not NULL). If the segments are barely touching (close within EPS), then the
  result will depend on the setting of TOUCH_IS_INTERSECT.
- closest_point(a, b, c, p) returns the point on line a*x + b*y + c = 0 that is
  closest to point p. Note that the result always lies on the line through p
  which is perpendicular to the line a*x + b*y + c = 0.
- closest_point(a, b, p) returns the point on segment ab closest to point p.

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <cstddef>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define LE(a, b) ((a) <= (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }
double dot(const point &a, const point &b) { return a.x*b.x + a.y*b.y; }
double cross(const point &a, const point &b) { return a.x*b.y - a.y*b.x; }

int line_intersection(double a1, double b1, double c1, double a2, double b2,
                      double c2, point *p = NULL) {
  if (EQ(a1, a2) && EQ(b1, b2)) {
    return EQ(c1, c2) ? 1 : -1;
  }
  if (p != NULL) {
    p->x = (b1*c1 - b1*c2) / (a2*b1 - a1*b2);
    if (!EQ(b1, 0)) {
      p->y = -(a1*p->x + c1) / b1;
    } else {
      p->y = -(a2*p->x + c2) / b2;
    }
  }
  return 0;
}

int line_intersection(const point &p1, const point &p2,
                      const point &p3, const point &p4, point *p = NULL) {
  double a1 = p2.y - p1.y, b1 = p1.x - p2.x;
  double c1 = -(p1.x*p2.y - p2.x*p1.y);
  double a2 = p4.y - p3.y, b2 = p3.x - p4.x;
  double c2 = -(p3.x*p4.y - p4.x*p3.y);
  double x = -(c1*b2 - c2*b1), y = -(a1*c2 - a2*c1);
  double det = a1*b2 - a2*b1;
  if (EQ(det, 0)) {
    return (EQ(x, 0) && EQ(y, 0)) ? 1 : -1;
  }
  if (p != NULL) {
    *p = point(x / det, y / det);
  }
  return 0;
}

int seg_intersection(const point &a, const point &b, const point &c,
                     const point &d, point *p = NULL, point *q = NULL) {
  static const bool TOUCH_IS_INTERSECT = true;
  point ab(b.x - a.x, b.y - a.y);
  point ac(c.x - a.x, c.y - a.y);
  point cd(d.x - c.x, d.y - c.y);
  double c1 = cross(ab, cd), c2 = cross(ac, ab);
  if (EQ(c1, 0) && EQ(c2, 0)) {  // Collinear.
    double t0 = dot(ac, ab) / sqnorm(ab);
    double t1 = t0 + dot(cd, ab) / sqnorm(ab);
    double mint = std::min(t0, t1), maxt = std::max(t0, t1);
    bool overlap = TOUCH_IS_INTERSECT ? (LE(mint, 1) && LE(0, maxt))
                                      : (LT(mint, 1) && LT(0, maxt));
    if (overlap) {
      point res1 = std::max(std::min(a, b), std::min(c, d));
      point res2 = std::min(std::max(a, b), std::max(c, d));
      if (res1 == res2) {
        if (p != NULL) {
          *p = res1;
        }
        return 0;  // Collinear and meeting at an endpoint.
      }
      if (p != NULL && q != NULL) {
        *p = res1;
        *q = res2;
      }
      return 1;  // Collinear and overlapping.
    } else {
      return -1;  // Collinear and disjoint.
    }
  }
  if (EQ(c1, 0)) {
    return -1;  // Parallel and disjoint.
  }
  double t = cross(ac, cd)/c1, u = c2/c1;
  bool t_between_01 = TOUCH_IS_INTERSECT ? (LE(0, t) && LE(t, 1))
                                         : (LT(0, t) && LT(t, 1));
  bool u_between_01 = TOUCH_IS_INTERSECT ? (LE(0, u) && LE(u, 1))
                                         : (LT(0, u) && LT(u, 1));
  if (t_between_01 && u_between_01) {
    if (p != NULL) {
      *p = point(a.x + t*ab.x, a.y + t*ab.y);
    }
    return 0;  // Non-parallel with one intersection.
  }
  return -1;  // Non-parallel with no intersections.
}

point closest_point(double a, double b, double c, const point &p) {
  if (EQ(a, 0)) {
    return point(p.x, -c);  // Horizontal line.
  }
  if (EQ(b, 0)) {
    return point(-c, p.y);  // Vertical line.
  }
  point res;
  line_intersection(a, b, c, -b, a, b*p.x - a*p.y, &res);
  return res;
}

point closest_point(const point &a, const point &b, const point &p) {
  if (a == b) return a;
  point ap(p.x - a.x, p.y - a.y), ab(b.x - a.x, b.y - a.y);
  double t = dot(ap, ab) / norm(ab);
  if (t <= 0) return a;
  if (t >= 1) return b;
  return point(a.x + t * ab.x, a.y + t * ab.y);
}

/*** Example Usage ***/

#include <cassert>
#define point point

bool EQP(const point &a, const point &b) {
  return EQ(a.x, b.x) && EQ(a.y, b.y);
}

int main() {
  point p, q;

  assert(line_intersection(-1, 1, 0, 1, 1, -3, &p) == 0);
  assert(EQP(p, point(1.5, 1.5)));
  assert(line_intersection(point(0, 0), point(1, 1), point(0, 4), point(4, 0),
                           &p) == 0);
  assert(EQP(p, point(2, 2)));

  {
    #define test(a, b, c, d, e, f, g, h) seg_intersection( \
        point(a, b), point(c, d), point(e, f), point(g, h), &p, &q)

    // Intersection is a point.
    assert(0 == test(-4, 0, 4, 0, 0, -4, 0, 4) && EQP(p, point(0, 0)));
    assert(0 == test(0, 0, 10, 10, 2, 2, 16, 4) && EQP(p, point(2, 2)));
    assert(0 == test(-2, 2, -2, -2, -2, 0, 0, 0) && EQP(p, point(-2, 0)));
    assert(0 == test(0, 4, 4, 4, 4, 0, 4, 8) && EQP(p, point(4, 4)));

    // Intersection is a segment.
    assert(1 == test(10, 10, 0, 0, 2, 2, 6, 6));
    assert(EQP(p, point(2, 2)) && EQP(q, point(6, 6)));
    assert(1 == test(6, 8, 14, -2, 14, -2, 6, 8));
    assert(EQP(p, point(6, 8)) && EQP(q, point(14, -2)));

    // No intersection.
    assert(-1 == test(6, 8, 8, 10, 12, 12, 4, 4));
    assert(-1 == test(-4, 2, -8, 8, 0, 0, -4, 6));
    assert(-1 == test(4, 4, 4, 6, 0, 2, 0, 0));
    assert(-1 == test(4, 4, 6, 4, 0, 2, 0, 0));
    assert(-1 == test(-2, -2, 4, 4, 10, 10, 6, 6));
    assert(-1 == test(0, 0, 2, 2, 4, 0, 1, 4));
    assert(-1 == test(2, 2, 2, 8, 4, 4, 6, 4));
    assert(-1 == test(4, 2, 4, 4, 0, 8, 10, 0));
  }

  assert(EQP(point(2.5, 2.5), closest_point(-1, -1, 5, point(0, 0))));
  assert(EQP(point(3, 0), closest_point(1, 0, -3, point(0, 0))));
  assert(EQP(point(0, 3), closest_point(0, 1, -3, point(0, 0))));

  assert(EQP(point(3, 0),
             closest_point(point(3, 0), point(3, 3), point(0, 0))));
  assert(EQP(point(2, -1),
             closest_point(point(2, -1), point(4, -1), point(0, 0))));
  assert(EQP(point(4, -1),
             closest_point(point(2, -1), point(4, -1), point(5, 0))));
  return 0;
}
\end{lstlisting}
\subsection{Circle Intersection}
\begin{lstlisting}
/*

Circle tangent and intersection calculations in two dimensions.

- tangent(c, p, &l1, &l2) determines the line(s) tangent to circle c that passes
  through point p, returning -1 if there is no tangent line because p is
  strictly inside c, 0 if there is exactly one tangent line because p is on the
  boundary of c (in which case the line will be stored into pointer l1 if it's
  not NULL), or 1 if there are two tangent lines because p is strictly outside
  of c (in which case the lines will be stored into pointers l1 and l2 if they
  are not NULL).
- intersection(c, l, &p, &q) determines the intersection between the circle c
  and line l, returning -1 if there is no intersection, 0 if the line is one
  intersection point because the line is tangent (in which case it will be
  stored into pointer p if it's not NULL), or 1 if there are two intersection
  points because the line crosses through the circle (in which case they will be
  stored into pointers p and q if they are not NULL).
- intersection(c1, c2, &p, &q) determines the intersection points between two
  circles c1 and c2, returning -2 if circle c2 completely encloses circle c1,
  -1 if circle c1 completely encloses circle c2, 0 if the circles are completely
  disjoint, 1 if the circles are tangent with one intersection (stored in p),
  2 if the circles intersect at two points (stored in p and q), 3 if the circles
  are equal and intersect at infinite points.
- intersection_area(c1, c2) returns the intersection area of circles c1 and c2.

Time Complexity:
- O(1) for all operations.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <cstddef>
#include <utility>

const double EPS = 1e-9, PI = acos(-1.0);

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define NE(a, b) (fabs((a) - (b)) > EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GT(a, b) ((a) > (b) + EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }

struct circle {
  double h, k, r;

  circle(double h, double k, double r) {
    this->h = h;
    this->k = k;
    this->r = r;
  }
};

struct line {
  double a, b, c;

  line() : a(0), b(0), c(0) {}

  line(double a, double b, double c) {
    if (!EQ(b, 0)) {
      this->a = a / b;
      this->c = c / b;
      this->b = 1;
    } else {
      this->c = c / a;
      this->a = 1;
      this->b = 0;
    }
  }

  line(const point &p, const point &q) : a(0), b(0), c(0) {
    if (EQ(p.x, q.x)) {
      if (NE(p.y, q.y)) {  // Vertical line.
        a = 1;
        b = 0;
        c = -p.x;
      }  // Else, invalid line.
    } else {
      a = -(p.y - q.y) / (p.x - q.x);
      b = 1;
      c = -(a*p.x) - (b*p.y);
    }
  }
};

int tangent(const circle &c, const point &p, line *l1 = NULL, line *l2 = NULL) {
  point vop(p.x - c.h, p.y - c.k);
  if (EQ(sqnorm(vop), c.r*c.r)) {  // Point on an edge.
    if (l1 != 0) {  // Get perpendicular line through p.
      *l1 = line(point(c.h, c.k), p);
      *l1 = line(-l1->b, l1->a, l1->b*p.x - l1->a*p.y);
    }
    return 0;
  }
  if (LE(sqnorm(vop), c.r*c.r)) {
    return -1;  // Point inside circle, no intersection.
  }
  point q(vop.x / c.r, vop.y / c.r);
  double n = sqnorm(q), d = q.y*sqrt(sqnorm(q) - 1.0);
  point t1((q.x - d) / n, c.k), t2((q.x + d) / n, c.k);
  if (NE(q.y, 0)) {  // Common case.
    t1.y += c.r*(1.0 - t1.x*q.x) / q.y;
    t2.y += c.r*(1.0 - t2.x*q.x) / q.y;
  } else {  // Point at center horizontal, y = 0.
    d = c.r*sqrt(1.0 - t1.x*t1.x);
    t1.y += d;
    t2.y -= d;
  }
  t1.x = t1.x*c.r + c.h;
  t2.x = t2.x*c.r + c.h;
  //note: here, t1 and t2 are the two points of tangencies
  if (l1 != NULL && l2 != NULL) {
    *l1 = line(p, t1);
    *l2 = line(p, t2);
  }
  return 1;
}

int intersection(const circle &c, const line &l, point *p = NULL,
                 point *q = NULL) {
  double v = c.h*l.a + c.k*l.b + l.c;
  double aabb = l.a*l.a + l.b*l.b;
  double disc = v*v / aabb - c.r*c.r;
  if (disc > EPS) {
    return -1;
  }
  double x0 = -l.a*l.c / aabb, y0 = -l.b*v / aabb;
  if (disc > -EPS) {
    if (p != NULL) {
      *p = point(x0 + c.h, y0 + c.k);
    }
    return 0;
  }
  double k = sqrt(std::max(0.0, disc / -aabb));
  if (p != NULL && q != NULL) {
    *p = point(x0 + k*l.b + c.h, y0 - k*l.a + c.k);
    *q = point(x0 - k*l.b + c.h, y0 + k*l.a + c.k);
  }
  return 1;
}

int intersection(const circle &c1, const circle &c2, point *p = NULL,
                 point *q = NULL) {
  if (EQ(c1.h, c2.h) && EQ(c1.k, c2.k)) {
    return EQ(c1.r, c2.r) ? 3 : (c1.r > c2.r ? -1 : -2);
  }
  point d12(point(c2.h - c1.h, c2.k - c1.k));
  double d = norm(d12);
  if (GT(d, c1.r + c2.r)) {
    return 0;
  }
  if (LT(d, fabs(c1.r - c2.r))) {
    return c1.r > c2.r ? -1 : -2;
  }
  double a = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);
  double x0 = c1.h + (d12.x*a / d), y0 = c1.k + (d12.y*a / d);
  double s = sqrt(c1.r*c1.r - a*a), rx = -d12.y*s / d, ry = d12.x*s / d;
  if (EQ(rx, 0) && EQ(ry, 0)) {
    if (p != NULL) {
      *p = point(x0, y0);
    }
    return 1;
  }
  if (p != NULL && q != NULL) {
    *p = point(x0 - rx, y0 - ry);
    *q = point(x0 + rx, y0 + ry);
  }
  return 2;
}

double intersection_area(const circle &c1, const circle &c2) {
  double r = std::min(c1.r, c2.r), R = std::max(c1.r, c2.r);
  double d = norm(point(c2.h - c1.h, c2.k - c1.k));
  if (LE(d, R - r)) {
    return PI*r*r;
  }
  if (GE(d, R + r)) {
    return 0;
  }
  return r*r*acos((d*d + r*r - R*R) / 2 / d / r) +
         R*R*acos((d*d + R*R - r*r) / 2 / d / R) -
         0.5*sqrt((-d + r + R)*(d + r - R)*(d - r + R)*(d + r + R));
}

/*** Example Usage ***/

#include <cassert>

bool EQP(const point &a, const point &b) {
  return EQ(a.x, b.x) && EQ(a.y, b.y);
}

bool EQL(const line &l1, const line &l2) {
  return EQ(l1.a, l2.a) && EQ(l1.b, l2.b) && EQ(l1.c, l2.c);
}

int main() {
  line l1, l2;
  assert(-1 == tangent(circle(0, 0, 4), point(1, 1), &l1, &l2));
  assert(0 == tangent(circle(0, 0, sqrt(2)), point(1, 1), &l1, &l2));
  assert(EQL(l1, line(-1, -1, 2)));
  assert(1 == tangent(circle(0, 0, 2), point(2, 2), &l1, &l2));
  assert(EQL(l1, line(0, -2, 4)));
  assert(EQL(l2, line(2, 0, -4)));

  point p, q;
  assert(-1 == intersection(circle(1, 1, 3), line(5, 3, -30), &p, &q));
  assert(0 == intersection(circle(1, 1, 3), line(0, 1, -4), &p, &q));
  assert(EQP(p, point(1, 4)));
  assert(1 == intersection(circle(1, 1, 3), line(0, 1, -1), &p, &q));
  assert(EQP(p, point(4, 1)));
  assert(EQP(q, point(-2, 1)));

  assert(-2 == intersection(circle(1, 1, 1), circle(0, 0, 3), &p, &q));
  assert(-1 == intersection(circle(0, 0, 3), circle(1, 1, 1), &p, &q));
  assert(0 == intersection(circle(5, 0, 4), circle(-5, 0, 4), &p, &q));
  assert(1 == intersection(circle(-5, 0, 5), circle(5, 0, 5), &p, &q));
  assert(EQP(p, point(0, 0)));
  assert(2 == intersection(circle(-0.5, 0, 1), circle(0.5, 0, 1), &p, &q));
  assert(EQP(p, point(0, -sqrt(3) / 2)));
  assert(EQP(q, point(0, sqrt(3) / 2)));

  // Each circle passes through the other's center.
  double r = 3, a = intersection_area(circle(-r/2, 0, r), circle(r/2, 0, r));
  assert(EQ(a, r*r*(2*PI / 3 - sqrt(3) / 2)));
  return 0;
}
\end{lstlisting}

\section{Intermediate Geometric Calculations}
\setcounter{section}{3}
\setcounter{subsection}{0}
\subsection{Polygon Sorting and Area}
\begin{lstlisting}
/*

Given a list of distinct points in two-dimensions, order them into a valid
polygon and determine the area.

- mean_center(lo, hi) returns the arithmetic mean of a range [lo, hi) of points,
  where lo and hi must be random-access iterators. This point is mathematically
  guaranteed to lie within the non-self-intersecting closed polygon constructed
  by sorting all other points clockwise about it. Note that this is different
  from the geometric centroid (a.k.a. barycenter) of a polygon.
- cw_comp(a, b, c) returns whether point a compares clockwise "before" point b
  when using c as a central reference point.
- cw_comp_class(c) constructs a wrapper class of cw_comp() that may be passed to
  std::sort() a range of points clockwise to produce a valid polygon.
- ccw_comp_class(c) constructs a wrapper class of cw_comp() that may be passed
  to std::sort() a range of points counter-clockwise to produce a valid polygon.
- polygon_area(lo, hi) returns the area of the polygon specified by the range
  [lo, hi) of points, where lo and hi must be BidirectionalIterators. The points
  are interpreted as a polygon based on the order given in the range. The input
  polygon does not have to be sorted using the methods above, but must be given
  in some ordering that yields a valid non-self-intersecting closed polygon.
  Optionally, the last point may be equal to the first point in the input
  without affecting the result. The area is computed using the shoelace formula.

Time Complexity:
- O(n) per call to mean_center(lo, hi) and polygon_area(lo, hi), where n is the
  distance between lo and hi.
- O(1) per call to cw_comp() and the related class comparators.

Space Complexity:
- O(1) auxiliary for all operations.

*/

#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double cross(const point &a, const point &b) { return a.x*b.y - a.y*b.x; }

template<class It>
point mean_center(It lo, It hi) {
  if (lo == hi) {
    throw std::runtime_error("Cannot get center of an empty range.");
  }
  double x_sum = 0, y_sum = 0, num_points = hi - lo;
  for (; lo != hi; ++lo) {
    x_sum += lo->x;
    y_sum += lo->y;
  }
  return point(x_sum / num_points, y_sum / num_points);
}

bool cw_comp(const point &a, const point &b, const point &c) {
  if (GE(a.x - c.x, 0) && LT(b.x - c.x, 0)) {
    return true;
  }
  if (LT(a.x - c.x, 0) && GE(b.x - c.x, 0)) {
    return false;
  }
  if (EQ(a.x - c.x, 0) && EQ(b.x - c.x, 0)) {
    if (GE(a.y - c.y, 0) || GE(b.y - c.y, 0)) {
      return a.y > b.y;
    }
    return b.y > a.y;
  }
  point ac(a.x - c.x, a.y - c.y), bc(b.x - c.x, b.y - c.y);
  double det = cross(ac, bc);
  if (EQ(det, 0)) {
    return sqnorm(ac) > sqnorm(bc);
  }
  return det < 0;
}

struct cw_comp_class {
  point c;
  cw_comp_class(const point &c) : c(c) {}
  bool operator()(const point &a, const point &b) const {
    return cw_comp(a, b, c);
  }
};

struct ccw_comp_class {
  point c;
  ccw_comp_class(const point &c) : c(c) {}
  bool operator()(const point &a, const point &b) const {
    return cw_comp(b, a, c);
  }
};

template<class It>
double polygon_area(It lo, It hi) {
  if (lo == hi) {
    return 0;
  }
  double area = 0;
  if (*lo != *--hi) {
    area += (lo->x - hi->x)*(lo->y + hi->y);
  }
  for (It i = hi, j = --hi; i != lo; --i, --j) {
    area += (i->x - j->x)*(i->y + j->y);
  }
  return fabs(area / 2.0);
}

/*** Example Usage ***/

#include <cassert>
#include <vector>
using namespace std;

int main() {
  // Irregular pentagon with only the vertex (1, 2) not on its convex hull.
  // The ordering here is already sorted in ccw order around their mean center,
  // though we will shuffle them to verify our sorting comparator.
  point points[] = {point(1, 3),
                    point(1, 2),
                    point(2, 1),
                    point(0, 0),
                    point(-1, 3)};
  vector<point> v(points, points + 5);
  std::random_shuffle(v.begin(), v.end());
  point c = mean_center(v.begin(), v.end());
  assert(EQ(c.x, 0.6) && EQ(c.y, 1.8));
  sort(v.begin(), v.end(), cw_comp_class(c));
  for (int i = 0; i < (int)v.size(); i++) {
    assert(v[i] == points[i]);
  }
  assert(EQ(polygon_area(v.begin(), v.end()), 5));
  return 0;
}
\end{lstlisting}
\subsection{Point-in-Polygon (Ray Casting)}
\begin{lstlisting}
/*

Given a point p and a polygon in two dimensions, determine whether p lies inside
the polygon using a ray casting algorithm.

- point_in_polygon(p, lo, hi) returns whether p lies within the polygon defined
  by the range [lo, hi) of points specifying the vertices in either clockwise
  or counter-clockwise order, where lo and hi must be random-access iterators.
  If p lies barely on an edge (within EPS), then the result will depend on the
  setting of EDGE_IS_INSIDE.

Time Complexity:
- O(n) per call to point_in_polygon(lo, hi), where n is the distance between lo
  and hi.

Space Complexity:
- O(1) auxiliary.

*/

#include <cmath>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LE(a, b) ((a) <= (b) + EPS)
#define GT(a, b) ((a) > (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

template<class It>
bool point_in_polygon(const point &p, It lo, It hi) {
  static const bool EDGE_IS_INSIDE = true;
  bool ans = 0;
  for (It i = lo, j = hi - 1; i != hi; j = i++) {
    if (EQ(i->y, p.y) &&
        (EQ(i->x, p.x) ||
         (EQ(j->y, p.y) && (LE(i->x, p.x) || LE(j->x, p.x))))) {
      return EDGE_IS_INSIDE;
    }
    if (GT(i->y, p.y) != GT(j->y, p.y)) {
      double det = cross(*i, *j, p);
      if (EQ(det, 0)) {
        return EDGE_IS_INSIDE;
      }
      if (GT(det, 0) != GT(j->y, i->y)) {
        ans = !ans;
      }
    }
  }
  return ans;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  // Irregular trapezoid.
  point p[] = {point(-1, 3), point(1, 3), point(2, 1), point(0, 0)};
  assert(point_in_polygon(point(1, 2), p, p + 4));
  assert(point_in_polygon(point(0, 3), p, p + 4));
  assert(!point_in_polygon(point(0, 3.01), p, p + 4));
  assert(!point_in_polygon(point(2, 2), p, p + 4));
  return 0;
}
\end{lstlisting}
\subsection{Convex Hull and Diametral Pair}
\begin{lstlisting}
/*

Given a list of points in two dimensions, determine the convex hull using the
monotone chain algorithm, and the diameter of the points using the method of
rotating calipers. The convex hull is the smallest convex polygon (a polygon
such that every line crossing through it will only do so once) that contains all
of its points.

- convex_hull(lo, hi) returns the convex hull as a vector of polygon vertices in
  clockwise order, given a range [lo, hi) of points where lo and hi must be
  random-access iterators. The input range will be sorted lexicographically (by
  x, then by y) after the function call. Note that to produce the hull points in
  counter-clockwise order, replace every GE() comparison with LE(). To have the
  first point on the hull repeated as the last in the resulting vector, the
  final res.resize(k - 1) may be changed to res.resize(k).
- diametral_pair(lo, hi) returns a maximum diametral pair given a range [lo, hi)
  of points where lo and hi must be random-access iterators. The input range
  will be sorted lexicographically (by x, then by y) after the function call.

Time Complexity:
- O(n log n) per call to convex_hull(lo, hi) and diametral_pair(lo, hi), where n
  is the distance between lo and hi.

Space Complexity:
- O(n) auxiliary for storage of the convex hull in both operations.

*/

#include <algorithm>
#include <cmath>
#include <utility>
#include <vector>

const double EPS = 1e-9;

#define GE(a, b) ((a) >= (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

template<class It>
std::vector<point> convex_hull(It lo, It hi) {
  int k = 0;
  if (hi - lo <= 1) {
    return std::vector<point>(lo, hi);
  }
  std::vector<point> res(2*(int)(hi - lo));
  std::sort(lo, hi);
  for (It it = lo; it != hi; ++it) {
    while (k >= 2 && GE(cross(res[k - 1], *it, res[k - 2]), 0)) {
      k--;
    }
    res[k++] = *it;
  }
  int t = k + 1;
  for (It it = hi - 2; it != lo - 1; --it) {
    while (k >= t && GE(cross(res[k - 1], *it, res[k - 2]), 0)) {
      k--;
    }
    res[k++] = *it;
  }
  res.resize(k - 1);
  return res;
}

template<class It>
std::pair<point, point> diametral_pair(It lo, It hi) {
  std::vector<point> h = convex_hull(lo, hi);
  int m = h.size();
  if (m == 1) {
    return std::make_pair(h[0], h[0]);
  }
  if (m == 2) {
    return std::make_pair(h[0], h[1]);
  }
  int k = 1;
  while (fabs(cross(h[0], h[(k + 1) % m], h[m - 1])) >
         fabs(cross(h[0], h[k], h[m - 1]))) {
    k++;
  }
  double maxdist = 0, d;
  std::pair<point, point> res;
  for (int i = 0, j = k; i <= k && j < m; i++) {
    d = sqnorm(point(h[i].x - h[j].x, h[i].y - h[j].y));
    if (d > maxdist) {
      maxdist = d;
      res = std::make_pair(h[i], h[j]);
    }
    while (j < m && fabs(cross(h[(i + 1) % m], h[(j + 1) % m], h[i])) >
                    fabs(cross(h[(i + 1) % m], h[j], h[i]))) {
      d = sqnorm(point(h[i].x - h[(j + 1) % m].x, h[i].y - h[(j + 1) % m].y));
      if (d > maxdist) {
        maxdist = d;
        res = std::make_pair(h[i], h[(j + 1) % m]);
      }
      j++;
    }
  }
  return res;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  { // Irregular pentagon with only the vertex (1, 2) not on the hull.
    vector<point> v;
    v.push_back(point(1, 3));
    v.push_back(point(1, 2));
    v.push_back(point(2, 1));
    v.push_back(point(0, 0));
    v.push_back(point(-1, 3));
    std::random_shuffle(v.begin(), v.end());
    vector<point> h;
    h.push_back(point(-1, 3));
    h.push_back(point(1, 3));
    h.push_back(point(2, 1));
    h.push_back(point(0, 0));
    assert(convex_hull(v.begin(), v.end()) == h);
  }
  {
    vector<point> v;
    v.push_back(point(0, 0));
    v.push_back(point(3, 0));
    v.push_back(point(0, 3));
    v.push_back(point(1, 1));
    v.push_back(point(4, 4));
    pair<point, point> res = diametral_pair(v.begin(), v.end());
    assert(res.first == point(0, 0));
    assert(res.second == point(4, 4));
  }
  return 0;
}
\end{lstlisting}
\subsection{Minimum Enclosing Circle}
\begin{lstlisting}
/*

Given a list of points in two dimensions, find the circle with smallest area
which contains all the given points using a randomized algorithm.

- minimum_enclosing_circle(lo, hi) returns the minimum enclosing circle given a
  range [lo, hi) of points, where lo and hi must be random-access iterators. The
  input range will be shuffled after the function call, though this is only to
  avoid the worst-case running time and is not necessary for correctness.

Time Complexity:
- O(n) on average per call to minimum_enclosing_circle(lo, hi), where n is the
  distance between lo and hi.

Space Complexity:
- O(1) auxiliary.

*/

#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LE(a, b) ((a) <= (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }

struct circle {
  double h, k, r;

  circle() : h(0), k(0), r(0) {}
  circle(double h, double k, double r) : h(h), k(k), r(fabs(r)) {}

  // Circle with the line segment ab as a diameter.
  circle(const point &a, const point &b) {
    h = (a.x + b.x)/2.0;
    k = (a.y + b.y)/2.0;
    r = norm(point(a.x - h, a.y - k));
  }

  // Circumcircle of three points.
  circle(const point &a, const point &b, const point &c) {
    double an = sqnorm(point(b.x - c.x, b.y - c.y));
    double bn = sqnorm(point(a.x - c.x, a.y - c.y));
    double cn = sqnorm(point(a.x - b.x, a.y - b.y));
    double wa = an*(bn + cn - an);
    double wb = bn*(an + cn - bn);
    double wc = cn*(an + bn - cn);
    double w = wa + wb + wc;
    if (EQ(w, 0)) {
      throw std::runtime_error("No circumcircle from collinear points.");
    }
    h = (wa*a.x + wb*b.x + wc*c.x)/w;
    k = (wa*a.y + wb*b.y + wc*c.y)/w;
    r = norm(point(a.x - h, a.y - k));
  }

  bool contains(const point &p) const {
    return LE(sqnorm(point(p.x - h, p.y - k)), r*r);
  }
};

template<class It>
circle minimum_enclosing_circle(It lo, It hi) {
  if (lo == hi) {
    return circle(0, 0, 0);
  }
  if (lo + 1 == hi) {
    return circle(lo->x, lo->y, 0);
  }
  std::random_shuffle(lo, hi);
  circle res(*lo, *(lo + 1));
  for (It i = lo + 2; i != hi; ++i) {
    if (res.contains(*i)) {
      continue;
    }
    res = circle(*lo, *i);
    for (It j = lo + 1; j != i; ++j) {
      if (res.contains(*j)) {
        continue;
      }
      res = circle(*i, *j);
      for (It k = lo; k != j; ++k) {
        if (!res.contains(*k)) {
          res = circle(*i, *j, *k);
        }
      }
    }
  }
  return res;
}

/*** Example Usage ***/

#include <cassert>
#include <vector>
using namespace std;

int main() {
  vector<point> v;
  v.push_back(point(0, 0));
  v.push_back(point(0, 1));
  v.push_back(point(1, 0));
  v.push_back(point(1, 1));
  circle res = minimum_enclosing_circle(v.begin(), v.end());
  assert(EQ(res.h, 0.5) && EQ(res.k, 0.5) && EQ(res.r, 1/sqrt(2)));
  return 0;
}
\end{lstlisting}
\subsection{Closest Pair}
\begin{lstlisting}
/*

Given a list of points in two dimensions, find the closest pair among them using
a divide and conquer algorithm.

- closest_pair(lo, hi, &res) returns the minimum Euclidean distance between any
  two pair of points in the range [lo, hi), where lo and hi must be
  random-access iterators. The input range will be sorted lexicographically (by
  x, then by y) after the function call. If there is an answer, the closest pair
  will be stored into pointer *res.

Time Complexity:
- O(n log^2 n) per call to closest_pair(lo, hi, &res), where n is the distance
  between lo and hi.

Space Complexity:
- O(n log^2 n) auxiliary stack space for closest_pair(lo, hi, &res), where n is
  the distance between lo and hi.

*/

#include <algorithm>
#include <cmath>
#include <limits>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }
bool cmp_x(const point &a, const point &b) { return LT(a.x, b.x); }
bool cmp_y(const point &a, const point &b) { return LT(a.y, b.y); }

template<class It>
double closest_pair(It lo, It hi, std::pair<point, point> *res = NULL,
                    double mindist = std::numeric_limits<double>::max(),
                    bool sort_x = true) {
  if (lo == hi) {
    return std::numeric_limits<double>::max();
  }
  if (sort_x) {
    std::sort(lo, hi, cmp_x);
  }
  It mid = lo + (hi - lo)/2;
  double midx = mid->x;
  double d1 = closest_pair(lo, mid, res, mindist, false);
  mindist = std::min(mindist, d1);
  double d2 = closest_pair(mid + 1, hi, res, mindist, false);
  mindist = std::min(mindist, d2);
  std::sort(lo, hi, cmp_y);
  int size = 0;
  It t[hi - lo];
  for (It it = lo; it != hi; ++it) {
    if (fabs(it->x - midx) < mindist) {
      t[size++] = it;
    }
  }
  for (int i = 0; i < size; i++) {
    for (int j = i + 1; j < size; j++) {
      point a(*t[i]), b(*t[j]);
      if (b.y - a.y >= mindist) {
        break;
      }
      double dist = norm(point(a.x - b.x, a.y - b.y));
      if (mindist > dist) {
        mindist = dist;
        if (res) {
          *res = std::make_pair(a, b);
        }
      }
    }
  }
  return mindist;
}

/*** Example Usage ***/

#include <cassert>
#include <vector>
using namespace std;

int main() {
  vector<point> v;
  v.push_back(point(2, 3));
  v.push_back(point(12, 30));
  v.push_back(point(40, 50));
  v.push_back(point(5, 1));
  v.push_back(point(12, 10));
  v.push_back(point(3, 4));
  pair<point, point> res;
  assert(EQ(closest_pair(v.begin(), v.end(), &res), sqrt(2)));
  assert(res.first == point(2, 3));
  assert(res.second == point(3, 4));
  return 0;
}
\end{lstlisting}
\subsection{Segment Intersection Finding}
\begin{lstlisting}
/*

Given a list of line segments in two dimensions, determine whether any pair of
segments intersect using a sweep line algorithm.

- find_intersection(lo, hi, &res1, &res2) returns whether any pair of segments
  intersect given a range [lo, hi) of segments, where lo and hi are
  random-access iterators. If there an intersection is found, then one such pair
  of segments will be stored into pointers res1 and res2. If some segments are
  barely touching (close within EPS), then the result will depend on the setting
  of TOUCH_IS_INTERSECT.

Time Complexity:
- O(n log n) per call to find_intersection(lo, hi, &res1, &res2), where n is
  the distance between lo and hi.

Space Complexity:
- O(n) auxiliary heap space for find_intersection(lo, hi, &res1, &res2), where n
  is the distance between lo and hi.

*/

#include <algorithm>
#include <cmath>
#include <set>
#include <utility>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define LE(a, b) ((a) <= (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double norm(const point &a) { return sqrt(sqnorm(a)); }
double dot(const point &a, const point &b) { return a.x*b.x + a.y*b.y; }
double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

int seg_intersection(const point &a, const point &b, const point &c,
                     const point &d, point *p = NULL, point *q = NULL) {
  static const bool TOUCH_IS_INTERSECT = true;
  point ab(b.x - a.x, b.y - a.y);
  point ac(c.x - a.x, c.y - a.y);
  point cd(d.x - c.x, d.y - c.y);
  double c1 = cross(ab, cd), c2 = cross(ac, ab);
  if (EQ(c1, 0) && EQ(c2, 0)) {  // Collinear.
    double t0 = dot(ac, ab) / sqnorm(ab);
    double t1 = t0 + dot(cd, ab) / sqnorm(ab);
    double mint = std::min(t0, t1), maxt = std::max(t0, t1);
    bool overlap = TOUCH_IS_INTERSECT ? (LE(mint, 1) && LE(0, maxt))
                                      : (LT(mint, 1) && LT(0, maxt));
    if (overlap) {
      point res1 = std::max(std::min(a, b), std::min(c, d));
      point res2 = std::min(std::max(a, b), std::max(c, d));
      if (res1 == res2) {
        if (p != NULL) {
          *p = res1;
        }
        return 0;  // Collinear and meeting at an endpoint.
      }
      if (p != NULL && q != NULL) {
        *p = res1;
        *q = res2;
      }
      return 1;  // Collinear and overlapping.
    } else {
      return -1;  // Collinear and disjoint.
    }
  }
  if (EQ(c1, 0)) {
    return -1;  // Parallel and disjoint.
  }
  double t = cross(ac, cd)/c1, u = c2/c1;
  bool t_between_01 = TOUCH_IS_INTERSECT ? (LE(0, t) && LE(t, 1))
                                         : (LT(0, t) && LT(t, 1));
  bool u_between_01 = TOUCH_IS_INTERSECT ? (LE(0, u) && LE(u, 1))
                                         : (LT(0, u) && LT(u, 1));
  if (t_between_01 && u_between_01) {
    if (p != NULL) {
      *p = point(a.x + t*ab.x, a.y + t*ab.y);
    }
    return 0;  // Non-parallel with one intersection.
  }
  return -1;  // Non-parallel with no intersections.
}

struct segment {
  point p, q;

  segment() {}
  segment(const point &p, const point &q) : p(min(p, q)), q(max(p, q)) {}

  bool operator<(const segment &rhs) const {
    if (p.x < rhs.p.x) {
      double c = cross(q, rhs.p, p);
      if (c != 0) {
        return c > 0;
      }
    } else if (rhs.p.x < p.x) {
      double c = cross(rhs.q, q, rhs.p);
      if (c != 0) {
        return c < 0;
      }
    }
    return p.y < rhs.p.y;
  }
};

template<class SegIt>
struct event {
  point p;
  int type;
  SegIt seg;

  event() {}
  event(const point &p, int type, SegIt seg) : p(p), type(type), seg(seg) {}

  bool operator<(const event &rhs) const {
    if (p.x != rhs.p.x) {
      return p.x < rhs.p.x;
    }
    if (type != rhs.type) {
      return rhs.type < type;
    }
    return p.y < rhs.p.y;
  }
};

bool intersect(const segment &s1, const segment &s2) {
  return seg_intersection(s1.p, s1.q, s2.p, s2.q) >= 0;
}

template<class It>
bool find_intersection(It lo, It hi, segment *res1, segment *res2) {
  int cnt = 0;
  event<It> e[2*(int)(hi - lo)];
  for (It it = lo; it != hi; ++it) {
    if (it->p > it->q) {
      std::swap(it->p, it->q);
    }
    e[cnt++] = event<It>(it->p, 1, it);
    e[cnt++] = event<It>(it->q, -1, it);
  }
  std::sort(e, e + cnt);
  std::set<segment> s;
  std::set<segment>::iterator it, next, prev;
  for (int i = 0; i < cnt; i++) {
    It seg = e[i].seg;
    if (e[i].type == 1) {
      it = s.lower_bound(*seg);
      if (it != s.end() && intersect(*it, *seg)) {
        *res1 = *it;
        *res2 = *seg;
        return true;
      }
      if (it != s.begin() && intersect(*--it, *seg)) {
        *res1 = *it;
        *res2 = *seg;
        return true;
      }
      s.insert(*seg);
    } else {
      it = s.lower_bound(*seg);
      next = prev = it;
      prev = it;
      if (it != s.begin() && it != --s.end()) {
        if (intersect(*(++next), *(--prev))) {
          *res1 = *next;
          *res2 = *prev;
          return true;
        }
      }
      s.erase(it);
    }
  }
  return false;
}

/*** Example Usage ***/

#include <vector>
using namespace std;

int main() {
  vector<segment> v;
  v.push_back(segment(point(0, 0), point(2, 2)));
  v.push_back(segment(point(3, 0), point(0, -1)));
  v.push_back(segment(point(0, 2), point(2, -2)));
  v.push_back(segment(point(0, 3), point(9, 0)));
  segment res1, res2;
  assert(find_intersection(v.begin(), v.end(), &res1, &res2));
  assert(res1.p == point(0, 0) && res1.q == point(2, 2));
  assert(res2.p == point(0, 2) && res2.q == point(2, -2));
  return 0;
}
\end{lstlisting}

\section{Advanced Geometric Computations}
\setcounter{section}{4}
\setcounter{subsection}{0}
\subsection{Convex Polygon Cut}
\begin{lstlisting}
/*

Given a convex polygon (a polygon such that every line crossing through it will
only do so once) in two dimensions, and two points specifying an infinite line,
cut off the right part of the polygon, and return the resulting left part.

- convex_cut(lo, hi, p, q) returns the points of the left side of a polygon, in
  clockwise order, after it has been cut by the line containing points p and q.
  The original convex polygon is given by the range [lo, hi) of points in
  clockwise order, where lo and hi must be random-access iterators.

Time Complexity:
- O(n) per call to convex_cut(lo, hi, p, q), where n is the distance between lo
  and hi.

Space Complexity:
- O(n) auxiliary for storage of the resulting convex cut.

*/

#include <cmath>
#include <cstddef>
#include <utility>
#include <vector>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define GT(a, b) ((a) > (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

int turn(const point &a, const point &o, const point &b) {
  double c = cross(a, b, o);
  return LT(c, 0) ? -1 : (GT(c, 0) ? 1 : 0);
}

int line_intersection(const point &p1, const point &p2,
                      const point &p3, const point &p4, point *p = NULL) {
  double a1 = p2.y - p1.y, b1 = p1.x - p2.x;
  double c1 = -(p1.x*p2.y - p2.x*p1.y);
  double a2 = p4.y - p3.y, b2 = p3.x - p4.x;
  double c2 = -(p3.x*p4.y - p4.x*p3.y);
  double x = -(c1*b2 - c2*b1), y = -(a1*c2 - a2*c1);
  double det = a1*b2 - a2*b1;
  if (EQ(det, 0)) {
    return (EQ(x, 0) && EQ(y, 0)) ? 1 : -1;
  }
  if (p != NULL) {
    *p = point(x / det, y / det);
  }
  return 0;
}

template<class It>
std::vector<point> convex_cut(It lo, It hi, const point &p, const point &q) {
  if (EQ(p.x, q.x) && EQ(p.y, q.y)) {
    throw std::runtime_error("Cannot cut using line from identical points.");
  }
  std::vector<point> res;
  for (It i = lo, j = hi - 1; i != hi; j = i++) {
    int d1 = turn(q, p, *j), d2 = turn(q, p, *i);
    if (d1 >= 0) {
      res.push_back(*j);
    }
    if (d1*d2 < 0) {
      point r;
      line_intersection(p, q, *j, *i, &r);
      res.push_back(r);
    }
  }
  return res;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  {
    vector<point> v;
    v.push_back(point(1, 3));
    v.push_back(point(2, 2));
    v.push_back(point(2, 1));
    v.push_back(point(0, 0));
    v.push_back(point(-1, 3));
    // Cut using the vertical line through (0, 0).
    vector<point> c;
    c.push_back(point(-1, 3));
    c.push_back(point(0, 3));
    c.push_back(point(0, 0));
    assert(convex_cut(v.begin(), v.end(), point(0, 0), point(0, 1)) == c);
  }
  { // On a non-convex input, the result may be multiple disjoint polygons!
    vector<point> v;
    v.push_back(point(0, 0));
    v.push_back(point(2, 2));
    v.push_back(point(0, 4));
    v.push_back(point(3, 4));
    v.push_back(point(3, 0));
    vector<point> c;
    c.push_back(point(1, 0));
    c.push_back(point(0, 0));
    c.push_back(point(1, 1));
    c.push_back(point(1, 3));
    c.push_back(point(0, 4));
    c.push_back(point(1, 4));
    assert(convex_cut(v.begin(), v.end(), point(1, 0), point(1, 4)) == c);
  }
  return 0;
}
\end{lstlisting}
\subsection{Polygon Intersection and Union}
\begin{lstlisting}
/*

Given two polygons, determine the areas of their intersection and union using a
sweep line algorithm and the inclusion-exclusion principle.

- intersection_area(lo1, hi1, lo2, hi2) returns the intersection area of two
  polygons respectively specified by two ranges [lo1, hi1) and [lo2, hi2) of
  vertices in clockwise order, where lo1, hi1, lo2, and hi2 must be
  random-access iterators.
- union_area(lo1, hi1, lo2, hi2) returns the union area of two polygons
  respectively specified by two ranges [lo1, hi1) and [lo2, hi2) of vertices in
  clockwise order, where lo1, hi1, lo2, and hi2 must be random-access iterators.

Time Complexity:
- O(n^2 log n) per call to intersection_area(lo1, hi1, lo2, hi2) and
  union_area(lo1, hi1, lo2, hi2) where n is the sum of distances between lo1 and
  hi1 and lo2 and hi2 respectively.

Space Complexity:
- O(n) auxiliary heap space for intersection_area(lo1, hi1, lo2, hi2) and
  union_area(lo1, hi1, lo2, hi2), where n is the sum of distances between lo1
  and hi1 and lo2 and hi2 respectively.

*/

#include <algorithm>
#include <cmath>
#include <set>
#include <utility>
#include <vector>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define LE(a, b) ((a) <= (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double dot(const point &a, const point &b) { return a.x*b.x + a.y*b.y; }
double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

int seg_intersection(const point &a, const point &b, const point &c,
                     const point &d, point *p = NULL, point *q = NULL) {
  static const bool TOUCH_IS_INTERSECT = true;
  point ab(b.x - a.x, b.y - a.y);
  point ac(c.x - a.x, c.y - a.y);
  point cd(d.x - c.x, d.y - c.y);
  double c1 = cross(ab, cd), c2 = cross(ac, ab);
  if (EQ(c1, 0) && EQ(c2, 0)) {  // Collinear.
    double t0 = dot(ac, ab) / sqnorm(ab);
    double t1 = t0 + dot(cd, ab) / sqnorm(ab);
    double mint = std::min(t0, t1), maxt = std::max(t0, t1);
    bool overlap = TOUCH_IS_INTERSECT ? (LE(mint, 1) && LE(0, maxt))
                                      : (LT(mint, 1) && LT(0, maxt));
    if (overlap) {
      point res1 = std::max(std::min(a, b), std::min(c, d));
      point res2 = std::min(std::max(a, b), std::max(c, d));
      if (res1 == res2) {
        if (p != NULL) {
          *p = res1;
        }
        return 0;  // Collinear and meeting at an endpoint.
      }
      if (p != NULL && q != NULL) {
        *p = res1;
        *q = res2;
      }
      return 1;  // Collinear and overlapping.
    } else {
      return -1;  // Collinear and disjoint.
    }
  }
  if (EQ(c1, 0)) {
    return -1;  // Parallel and disjoint.
  }
  double t = cross(ac, cd)/c1, u = c2/c1;
  bool t_between_01 = TOUCH_IS_INTERSECT ? (LE(0, t) && LE(t, 1))
                                         : (LT(0, t) && LT(t, 1));
  bool u_between_01 = TOUCH_IS_INTERSECT ? (LE(0, u) && LE(u, 1))
                                         : (LT(0, u) && LT(u, 1));
  if (t_between_01 && u_between_01) {
    if (p != NULL) {
      *p = point(a.x + t*ab.x, a.y + t*ab.y);
    }
    return 0;  // Non-parallel with one intersection.
  }
  return -1;  // Non-parallel with no intersections.
}

int line_intersection(const point &p1, const point &p2,
                      const point &p3, const point &p4, point *p = NULL) {
  double a1 = p2.y - p1.y, b1 = p1.x - p2.x;
  double c1 = -(p1.x*p2.y - p2.x*p1.y);
  double a2 = p4.y - p3.y, b2 = p3.x - p4.x;
  double c2 = -(p3.x*p4.y - p4.x*p3.y);
  double x = -(c1*b2 - c2*b1), y = -(a1*c2 - a2*c1);
  double det = a1*b2 - a2*b1;
  if (EQ(det, 0)) {
    return (EQ(x, 0) && EQ(y, 0)) ? 1 : -1;
  }
  if (p != NULL) {
    *p = point(x / det, y / det);
  }
  return 0;
}

struct event {
  double y;
  int mask_delta;

  event(double y = 0, int mask_delta = 0) {
    this->y = y;
    this->mask_delta = mask_delta;
  }

  bool operator<(const event &e) const {
    if (y != e.y) {
      return y < e.y;
    }
    return mask_delta < e.mask_delta;
  }
};

template<class It>
double intersection_area(It lo1, It hi1, It lo2, It hi2) {
  It plo[2] = {lo1, lo2}, phi[] = {hi1, hi2};
  std::set<double> xs;
  for (It i1 = lo1; i1 != hi1; ++i1) {
    xs.insert(i1->x);
  }
  for (It i2 = lo2; i2 != hi2; ++i2) {
    xs.insert(i2->x);
  }
  for (It i1 = lo1, j1 = hi1 - 1; i1 != hi1; j1 = i1++) {
    for (It i2 = lo2, j2 = hi2 - 1; i2 != hi2; j2 = i2++) {
      point p;
      if (seg_intersection(*i1, *j1, *i2, *j2, &p) == 0) {
        xs.insert(p.x);
      }
    }
  }
  std::vector<double> xsa(xs.begin(), xs.end());
  double res = 0;
  for (int k = 0; k < (int)xsa.size() - 1; k++) {
    double x = (xsa[k] + xsa[k + 1])/2;
    point sweep0(x, 0), sweep1(x, 1);
    std::vector<event> events;
    for (int poly = 0; poly < 2; poly++) {
      It lo = plo[poly], hi = phi[poly];
      double area = 0;
      for (It i = lo, j = hi - 1; i != hi; j = i++) {
        area += (j->x - i->x)*(j->y + i->y);
      }
      for (It j = lo, i = hi - 1; j != hi; i = j++) {
        point p;
        if (line_intersection(*j, *i, sweep0, sweep1, &p) == 0) {
          double y = p.y, x0 = i->x, x1 = j->x;
          int sgn_area = (area < 0 ? -1 : (area > 0 ? 1 : 0));
          if (x0 < x && x1 > x) {
            events.push_back(event(y, sgn_area*(1 << poly)));
          } else if (x0 > x && x1 < x) {
            events.push_back(event(y, -sgn_area*(1 << poly)));
          }
        }
      }
    }
    std::sort(events.begin(), events.end());
    double a = 0;
    int mask = 0;
    for (int j = 0; j < (int)events.size(); j++) {
      if (mask == 3) {
        a += events[j].y - events[j - 1].y;
      }
      mask += events[j].mask_delta;
    }
    res += a*(xsa[k + 1] - xsa[k]);
  }
  return res;
}

template<class It>
double polygon_area(It lo, It hi) {
  if (lo == hi) {
    return 0;
  }
  double area = 0;
  if (*lo != *--hi) {
    area += (lo->x - hi->x)*(lo->y + hi->y);
  }
  for (It i = hi, j = --hi; i != lo; --i, --j) {
    area += (i->x - j->x)*(i->y + j->y);
  }
  return fabs(area / 2.0);
}

template<class It>
double union_area(It lo1, It hi1, It lo2, It hi2) {
  return polygon_area(lo1, hi1) + polygon_area(lo2, hi2) -
         intersection_area(lo1, hi1, lo2, hi2);
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  vector<point> p, s;
  // Irregular pentagon a triangle of area 1.5 overlapping quadrant 2.
  p.push_back(point(1, 3));
  p.push_back(point(1, 2));
  p.push_back(point(2, 1));
  p.push_back(point(0, 0));
  p.push_back(point(-1, 3));
  // Square of area 12.5 in quadrant 2.
  s.push_back(point(0, 0));
  s.push_back(point(0, 3));
  s.push_back(point(-3, 3));
  s.push_back(point(-3, 0));
  assert(EQ(1.5, intersection_area(p.begin(), p.end(), s.begin(), s.end())));
  assert(EQ(12.5, union_area(p.begin(), p.end(), s.begin(), s.end())));
  return 0;
}
\end{lstlisting}
\subsection{Delaunay Triangulation (Simple)}
\begin{lstlisting}
/*

Given a set P of two dimensional points, the Delaunay triangulation of P is a
set of non-overlapping triangles that covers the entire convex hull of P such
that no point in P lies within the circumcircle of any of the resulting
triangles. For any point p in the convex hull of P (but not necessarily in P),
the nearest point is guaranteed to be a vertex of the enclosing triangle from
the triangulation.

The triangulation may not exist (e.g. for a set of collinear points), or may not
be unique if it does exists. The following program assumes its existence and
produces one such valid result using a simple algorithm which encases each
triangle in a circle and rejecting the triangle if another point in the
tessellation is within the generalized circle.

- delaunay_triangulation(lo, hi) returns a Delaunay triangulation for the input
  range [lo, hi) of points, where lo and hi must be random-access iterators, or
  an empty vector if a triangulation does not exist.

Time Complexity:
- O(n^4) per call to delaunay_triangulation(lo, hi), where n is the distance
  between lo and hi.

Space Complexity:
- O(n) auxiliary heap space for storage of the Delaunay triangulation.

*/

#include <algorithm>
#include <cmath>
#include <utility>
#include <vector>

const double EPS = 1e-9;

#define EQ(a, b) (fabs((a) - (b)) <= EPS)
#define LT(a, b) ((a) < (b) - EPS)
#define LE(a, b) ((a) <= (b) + EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

double sqnorm(const point &a) { return a.x*a.x + a.y*a.y; }
double dot(const point &a, const point &b) { return a.x*b.x + a.y*b.y; }
double cross(const point &a, const point &b, const point &o = point(0, 0)) {
  return (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
}

int seg_intersection(const point &a, const point &b, const point &c,
                     const point &d, point *p = NULL, point *q = NULL) {
  static const bool TOUCH_IS_INTERSECT = false;  // false is important!
  point ab(b.x - a.x, b.y - a.y);
  point ac(c.x - a.x, c.y - a.y);
  point cd(d.x - c.x, d.y - c.y);
  double c1 = cross(ab, cd), c2 = cross(ac, ab);
  if (EQ(c1, 0) && EQ(c2, 0)) {  // Collinear.
    double t0 = dot(ac, ab) / sqnorm(ab);
    double t1 = t0 + dot(cd, ab) / sqnorm(ab);
    double mint = std::min(t0, t1), maxt = std::max(t0, t1);
    bool overlap = TOUCH_IS_INTERSECT ? (LE(mint, 1) && LE(0, maxt))
                                      : (LT(mint, 1) && LT(0, maxt));
    if (overlap) {
      point res1 = std::max(std::min(a, b), std::min(c, d));
      point res2 = std::min(std::max(a, b), std::max(c, d));
      if (res1 == res2) {
        if (p != NULL) {
          *p = res1;
        }
        return 0;  // Collinear and meeting at an endpoint.
      }
      if (p != NULL && q != NULL) {
        *p = res1;
        *q = res2;
      }
      return 1;  // Collinear and overlapping.
    } else {
      return -1;  // Collinear and disjoint.
    }
  }
  if (EQ(c1, 0)) {
    return -1;  // Parallel and disjoint.
  }
  double t = cross(ac, cd)/c1, u = c2/c1;
  bool t_between_01 = TOUCH_IS_INTERSECT ? (LE(0, t) && LE(t, 1))
                                         : (LT(0, t) && LT(t, 1));
  bool u_between_01 = TOUCH_IS_INTERSECT ? (LE(0, u) && LE(u, 1))
                                         : (LT(0, u) && LT(u, 1));
  if (t_between_01 && u_between_01) {
    if (p != NULL) {
      *p = point(a.x + t*ab.x, a.y + t*ab.y);
    }
    return 0;  // Non-parallel with one intersection.
  }
  return -1;  // Non-parallel with no intersections.
}

struct triangle {
  point a, b, c;

  triangle(const point &a, const point &b, const point &c) : a(a), b(b), c(c) {}

  bool operator==(const triangle &t) const {
    return EQ(a.x, t.a.x) && EQ(a.y, t.a.y) &&
           EQ(b.x, t.b.x) && EQ(b.y, t.b.y) &&
           EQ(c.x, t.c.x) && EQ(c.y, t.c.y);
  }
};

template<class It>
std::vector<triangle> delaunay_triangulation(It lo, It hi) {
  int n = hi - lo;
  std::vector<double> x, y, z;
  for (It it = lo; it != hi; ++it) {
    x.push_back(it->x);
    y.push_back(it->y);
    z.push_back(sqnorm(*it));
  }
  std::vector<triangle> res;
  for (int i = 0; i < n - 2; i++) {
    for (int j = i + 1; j < n; j++) {
      for (int k = i + 1; k < n; k++) {
        if (j == k) {
          continue;
        }
        double nx = (y[j] - y[i])*(z[k] - z[i]) - (y[k] - y[i])*(z[j] - z[i]);
        double ny = (x[k] - x[i])*(z[j] - z[i]) - (x[j] - x[i])*(z[k] - z[i]);
        double nz = (x[j] - x[i])*(y[k] - y[i]) - (x[k] - x[i])*(y[j] - y[i]);
        if (LE(0, nz)) {
          continue;
        }
        point s1[] = {lo[i], lo[j], lo[k], lo[i]};
        for (int m = 0; m < n; m++) {
          if (nx*(x[m] - x[i]) + ny*(y[m] - y[i]) + nz*(z[m] - z[i]) > 0) {
            goto skip;
          }
        }
        // Handle four points on a circle.
        for (int t = 0; t < (int)res.size(); t++) {
          point s2[] = {res[t].a, res[t].b, res[t].c, res[t].a};
          for (int u = 0; u < 3; u++) {
            for (int v = 0; v < 3; v++) {
              if (seg_intersection(s1[u], s1[u + 1], s2[v], s2[v + 1]) == 0) {
                goto skip;
              }
            }
          }
        }
        res.push_back(triangle(lo[i], lo[j], lo[k]));
        skip:;
      }
    }
  }
  return res;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  vector<point> v;
  v.push_back(point(1, 3));
  v.push_back(point(1, 2));
  v.push_back(point(2, 1));
  v.push_back(point(0, 0));
  v.push_back(point(-1, 3));
  vector<triangle> t;
  t.push_back(triangle(point(1, 3), point(1, 2), point(-1, 3)));
  t.push_back(triangle(point(1, 3), point(2, 1), point(1, 2)));
  t.push_back(triangle(point(1, 2), point(2, 1), point(0, 0)));
  t.push_back(triangle(point(1, 2), point(0, 0), point(-1, 3)));
  assert(delaunay_triangulation(v.begin(), v.end()) == t);
  return 0;
}
\end{lstlisting}
\subsection{Delaunay Triangulation (Fast)}
\begin{lstlisting}
/*

Given a set P of two dimensional points, the Delaunay triangulation of P is a
set of non-overlapping triangles that covers the entire convex hull of P such
that no point in P lies within the circumcircle of any of the resulting
triangles. For any point p in the convex hull of P (but not necessarily in P),
the nearest point is guaranteed to be a vertex of the enclosing triangle from
the triangulation.

The triangulation may not exist (e.g. for a set of collinear points), or may not
be unique if it does exists. The following program assumes its existence and
produces one such valid result using TABLE_DELAUNAY, a divide and conquer
algorithm with linear merging. Its fully documented version along with debugging
messages for the current asserts() may be found at the following link:
http://people.sc.fsu.edu/~jburkardt/f_src/table_delaunay/table_delaunay.html

- delaunay_triangulation(lo, hi) returns a Delaunay triangulation for the input
  range [lo, hi) of points, where lo and hi must be random-access iterators, or
  an empty vector if a triangulation does not exist.

Time Complexity:
- O(n log n) per call to delaunay_triangulation(lo, hi), where n is the distance
  between lo and hi.

Space Complexity:
- O(n) auxiliary heap space for storage of the Delaunay triangulation.

*/

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <limits>
#include <utility>
#include <vector>

int wrap(int ival, int ilo, int ihi) {
  int jlo = std::min(ilo, ihi), jhi = std::max(ilo, ihi);
  int wide = jhi + 1 - jlo, res = jlo;
  if (wide != 1)  {
    assert(wide != 0);
    int tmp = (ival - jlo) % wide;
    if (tmp < 0) {
      res += std::abs(wide);
    }
    res += tmp;
  }
  return res;
}

void permute(int n, double a[][2], int p[]) {
  for (int istart = 1; istart <= n; istart++) {
    if (p[istart - 1] < 0) {
      continue;
    }
    if (p[istart - 1] == istart) {
      p[istart - 1] = -p[istart - 1];
      continue;
    }
    double tmp0 = a[istart - 1][0], tmp1 = a[istart - 1][1];
    int iget = istart;
    for (;;) {
      int iput = iget;
      iget = p[iget - 1];
      p[iput - 1] = -p[iput - 1];
      assert(!(iget < 1 || n < iget));
      if (iget == istart) {
        a[iput - 1][0] = tmp0;
        a[iput - 1][1] = tmp1;
        break;
      }
      a[iput - 1][0] = a[iget - 1][0];
      a[iput - 1][1] = a[iget - 1][1];
    }
  }
  for (int i = 0; i < n; i++) {
    p[i] = -p[i];
  }
}

int* sort_heap(int n, double a[][2]) {
  double aval[2];
  int i, ir, j, l, idxt;
  int *idx;
  if (n < 1) {
    return NULL;
  }
  if (n == 1) {
    idx = new int[1];
    idx[0] = 1;
    return idx;
  }
  idx = new int[n];
  for (int i = 0; i < n; i++) {
    idx[i] = i + 1;
  }
  l = n/2 + 1;
  ir = n;
  for (;;) {
    if (1 < l) {
      l--;
      idxt = idx[l - 1];
      aval[0] = a[idxt - 1][0];
      aval[1] = a[idxt - 1][1];
    } else {
      idxt = idx[ir - 1];
      aval[0] = a[idxt - 1][0];
      aval[1] = a[idxt - 1][1];
      idx[ir - 1] = idx[0];
      if (--ir == 1) {
        idx[0] = idxt;
        break;
      }
    }
    i = l;
    j = 2*l;
    while (j <= ir) {
      if (j < ir && (a[idx[j - 1] - 1][0] <  a[idx[j] - 1][0] ||
                    (a[idx[j - 1] - 1][0] == a[idx[j] - 1][0] &&
                     a[idx[j - 1] - 1][1] <  a[idx[j] - 1][1]))) {
        j++;
      }
      if ( aval[0]  < a[idx[j - 1] - 1][0] ||
          (aval[0] == a[idx[j - 1] - 1][0] &&
           aval[1]  < a[idx[j - 1] - 1][1])) {
        idx[i - 1] = idx[j - 1];
        i = j;
        j *= 2;
      } else {
        j = ir + 1;
      }
    }
    idx[i - 1] = idxt;
  }
  return idx;
}

int lrline(double xu, double yu, double xv1, double yv1,
          double xv2, double yv2, double dv) {
  static const double tol = 1e-7;
  double dx = xv2 - xv1, dy = yv2 - yv1;
  double dxu = xu - xv1, dyu = yu - yv1;
  double t = dy*dxu - dx*dyu + dv*sqrt(dx*dx + dy*dy);
  double tolabs = tol*std::max(std::max(fabs(dx), fabs(dy)),
                      std::max(fabs(dxu), std::max(fabs(dyu), fabs(dv))));
  return tolabs < t ? 1 : (-tolabs <= t ? 0 : -1);
}

void vbedg(double x, double y, int point_num, double point_xy[][2],
           int tri_num, int tri_nodes[][3], int tri_neigh[][3],
           int *ltri, int *ledg, int *rtri, int *redg) {
  int a, b;
  double ax, ay, bx, by;
  bool done;
  int e, l, t;
  if (*ltri == 0) {
    done = false;
    *ltri = *rtri;
    *ledg = *redg;
  } else {
    done = true;
  }
  for (;;) {
    l = -tri_neigh[*rtri - 1][*redg - 1];
    t = l / 3;
    e = l % 3 + 1;
    a = tri_nodes[t - 1][e - 1];
    if (e <= 2) {
      b = tri_nodes[t - 1][e];
    } else {
      b = tri_nodes[t - 1][0];
    }
    ax = point_xy[a - 1][0];
    ay = point_xy[a - 1][1];
    bx = point_xy[b - 1][0];
    by = point_xy[b - 1][1];
    if (lrline(x, y, ax, ay, bx, by, 0.0) <= 0) {
      break;
    }
    *rtri = t;
    *redg = e;
  }
  if (done) {
    return;
  }
  t = *ltri;
  e = *ledg;
  for (;;) {
    b = tri_nodes[t - 1][e - 1];
    e = wrap(e - 1, 1, 3);
    while (0 < tri_neigh[t - 1][e - 1]) {
      t = tri_neigh[t - 1][e - 1];
      if (tri_nodes[t - 1][0] == b) {
        e = 3;
      } else if (tri_nodes[t - 1][1] == b) {
        e = 1;
      } else {
        e = 2;
      }
    }
    a = tri_nodes[t - 1][e - 1];
    ax = point_xy[a - 1][0];
    ay = point_xy[a - 1][1];
    bx = point_xy[b - 1][0];
    by = point_xy[b - 1][1];
    if (lrline(x, y, ax, ay, bx, by, 0.0) <= 0) {
      break;
    }
  }
  *ltri = t;
  *ledg = e;
  return;
}

int diaedg(double x0, double y0, double x1, double y1,
           double x2, double y2, double x3, double y3) {
  double ca, cb, s, tol, tola, tolb;
  int value;
  tol = 100.0*std::numeric_limits<double>::epsilon();
  double dx10 = x1 - x0, dy10 = y1 - y0;
  double dx12 = x1 - x2, dy12 = y1 - y2;
  double dx30 = x3 - x0, dy30 = y3 - y0;
  double dx32 = x3 - x2, dy32 = y3 - y2;
  tola = tol*std::max(std::max(fabs(dx10), fabs(dy10)),
                      std::max(fabs(dx30), fabs(dy30)));
  tolb = tol*std::max(std::max(fabs(dx12), fabs(dy12)),
                      std::max(fabs(dx32), fabs(dy32)));
  ca = dx10*dx30 + dy10*dy30;
  cb = dx12*dx32 + dy12*dy32;
  if (tola < ca && tolb < cb) {
    value = -1;
  } else if (ca < -tola && cb < -tolb) {
    value = 1;
  } else {
    tola = std::max(tola, tolb);
    s = (dx10*dy30 - dx30*dy10)*cb + (dx32*dy12 - dx12*dy32)*ca;
    if (tola < s) {
      value = -1;
    } else if (s < -tola) {
      value = 1;
    } else {
      value = 0;
    }
  }
  return value;
}

int swapec(int i, int *top, int *btri, int *bedg, int point_num,
           double point_xy[][2], int tri_num, int tri_nodes[][3],
           int tri_neigh[][3], int stack[]) {
  int a, b, c, e, ee, em1, ep1, f, fm1, fp1, l, r, s, swap, t, tt, u;
  double x = point_xy[i - 1][0], y = point_xy[i - 1][1];
  for (;;) {
    if (*top <= 0) {
      break;
    }
    t = stack[*top - 1];
    *top -= 1;
    if (tri_nodes[t - 1][0] == i) {
      e = 2;
      b = tri_nodes[t - 1][2];
    } else if (tri_nodes[t - 1][1] == i) {
      e = 3;
      b = tri_nodes[t - 1][0];
    } else {
      e = 1;
      b = tri_nodes[t - 1][1];
    }
    a = tri_nodes[t - 1][e - 1];
    u = tri_neigh[t - 1][e - 1];
    if (tri_neigh[u - 1][0] == t) {
      f = 1;
      c = tri_nodes[u - 1][2];
    } else if (tri_neigh[u - 1][1] == t) {
      f = 2;
      c = tri_nodes[u - 1][0];
    } else {
      f = 3;
      c = tri_nodes[u - 1][1];
    }
    swap = diaedg(x, y, point_xy[a - 1][0], point_xy[a - 1][1],
                        point_xy[c - 1][0], point_xy[c - 1][1],
                        point_xy[b - 1][0], point_xy[b - 1][1]);
    if (swap == 1) {
      em1 = wrap(e - 1, 1, 3);
      ep1 = wrap(e + 1, 1, 3);
      fm1 = wrap(f - 1, 1, 3);
      fp1 = wrap(f + 1, 1, 3);
      tri_nodes[t - 1][ep1 - 1] = c;
      tri_nodes[u - 1][fp1 - 1] = i;
      r = tri_neigh[t - 1][ep1 - 1];
      s = tri_neigh[u - 1][fp1 - 1];
      tri_neigh[t - 1][ep1 - 1] = u;
      tri_neigh[u - 1][fp1 - 1] = t;
      tri_neigh[t - 1][e - 1] = s;
      tri_neigh[u - 1][f - 1] = r;
      if (0 < tri_neigh[u - 1][fm1 - 1]) {
        *top += 1;
        stack[*top - 1] = u;
      }
      if (0 < s) {
        if (tri_neigh[s - 1][0] == u) {
          tri_neigh[s - 1][0] = t;
        } else if (tri_neigh[s - 1][1] == u) {
          tri_neigh[s - 1][1] = t;
        } else {
          tri_neigh[s - 1][2] = t;
        }
        *top += 1;
        if (point_num < *top) {
          return 8;
        }
        stack[*top - 1] = t;
      } else {
        if (u == *btri && fp1 == *bedg) {
          *btri = t;
          *bedg = e;
        }
        l = - (3*t + e - 1);
        tt = t;
        ee = em1;
        while (0 < tri_neigh[tt - 1][ee - 1]) {
          tt = tri_neigh[tt - 1][ee - 1];
          if (tri_nodes[tt - 1][0] == a) {
            ee = 3;
          } else if (tri_nodes[tt - 1][1] == a) {
            ee = 1;
          } else {
            ee = 2;
          }
        }
        tri_neigh[tt - 1][ee - 1] = l;
      }
      if (0 < r) {
        if (tri_neigh[r - 1][0] == t) {
          tri_neigh[r - 1][0] = u;
        } else if (tri_neigh[r - 1][1] == t) {
          tri_neigh[r - 1][1] = u;
        } else {
          tri_neigh[r - 1][2] = u;
        }
      } else {
        if (t == *btri && ep1 == *bedg) {
          *btri = u;
          *bedg = f;
        }
        l = -(3*u + f - 1);
        tt = u;
        ee = fm1;
        while (0 < tri_neigh[tt - 1][ee - 1]) {
          tt = tri_neigh[tt - 1][ee - 1];
          if (tri_nodes[tt - 1][0] == b) {
            ee = 3;
          } else if (tri_nodes[tt - 1][1] == b) {
            ee = 1;
          } else {
            ee = 2;
          }
        }
        tri_neigh[tt - 1][ee - 1] = l;
      }
    }
  }
  return 0;
}

void perm_inv(int n, int p[]) {
  int i, i0, i1, i2;
  assert(n > 0);
  for (i = 1; i <= n; i++) {
    i1 = p[i - 1];
    while (i < i1) {
      i2 = p[i1 - 1];
      p[i1 - 1] = -i2;
      i1 = i2;
    }
    p[i - 1] = -p[i - 1];
  }
  for (i = 1; i <= n; i++) {
    i1 = -p[i - 1];
    if (0 <= i1) {
      i0 = i;
      for (;;) {
        i2 = p[i1 - 1];
        p[i1 - 1] = i0;
        if (i2 < 0) {
          break;
        }
        i0 = i1;
        i1 = i2;
      }
    }
  }
}

int dtris2(int point_num, double point_xy[][2],
           int tri_nodes[][3], int tri_neigh[][3]) {
  double cmax;
  int e, error;
  int i, j, k, l, m, m1, m2, n;
  int ledg, lr, ltri, redg, rtri, t, top;
  double tol;
  int *stack = new int[point_num];
  tol = 100.0*std::numeric_limits<double>::epsilon();
  int *idx = sort_heap(point_num, point_xy);
  permute(point_num, point_xy, idx);
  m1 = 0;
  for (i = 1; i < point_num; i++) {
    m = m1;
    m1 = i;
    k = -1;
    for (j = 0; j <= 1; j++) {
      cmax = std::max(fabs(point_xy[m][j]), fabs(point_xy[m1][j]));
      if (tol*(cmax + 1.0) < fabs(point_xy[m][j] - point_xy[m1][j])) {
        k = j;
        break;
      }
    }
    assert(k != -1);
  }
  m1 = 1;
  m2 = 2;
  j = 3;
  for (;;) {
    assert(point_num >= j);
    m = j;
    lr = lrline(point_xy[m - 1][0], point_xy[m - 1][1],
                point_xy[m1 - 1][0], point_xy[m1 - 1][1],
                point_xy[m2 - 1][0], point_xy[m2 - 1][1], 0.0);
    if (lr != 0) {
      break;
    }
    j++;
  }
  int tri_num = j - 2;
  if (lr == -1) {
    tri_nodes[0][0] = m1;
    tri_nodes[0][1] = m2;
    tri_nodes[0][2] = m;
    tri_neigh[0][2] = -3;
    for (i = 2; i <= tri_num; i++) {
      m1 = m2;
      m2 = i + 1;
      tri_nodes[i - 1][0] = m1;
      tri_nodes[i - 1][1] = m2;
      tri_nodes[i - 1][2] = m;
      tri_neigh[i - 1][0] = -3*i;
      tri_neigh[i - 1][1] = i;
      tri_neigh[i - 1][2] = i - 1;
    }
    tri_neigh[tri_num - 1][0] = -3*tri_num - 1;
    tri_neigh[tri_num - 1][1] = -5;
    ledg = 2;
    ltri = tri_num;
  } else {
    tri_nodes[0][0] = m2;
    tri_nodes[0][1] = m1;
    tri_nodes[0][2] = m;
    tri_neigh[0][0] = -4;
    for (i = 2; i <= tri_num; i++) {
      m1 = m2;
      m2 = i+1;
      tri_nodes[i - 1][0] = m2;
      tri_nodes[i - 1][1] = m1;
      tri_nodes[i - 1][2] = m;
      tri_neigh[i - 2][2] = i;
      tri_neigh[i - 1][0] = -3*i - 3;
      tri_neigh[i - 1][1] = i - 1;
    }
    tri_neigh[tri_num - 1][2] = -3*(tri_num);
    tri_neigh[0][1] = -3*(tri_num) - 2;
    ledg = 2;
    ltri = 1;
  }
  top = 0;
  for (i = j + 1; i <= point_num; i++) {
    m = i;
    m1 = tri_nodes[ltri - 1][ledg - 1];
    if (ledg <= 2) {
      m2 = tri_nodes[ltri - 1][ledg];
    } else {
      m2 = tri_nodes[ltri - 1][0];
    }
    lr = lrline(point_xy[m - 1][0], point_xy[m - 1][1],
                point_xy[m1 - 1][0], point_xy[m1 - 1][1],
                point_xy[m2 - 1][0], point_xy[m2 - 1][1], 0.0);
    if (0 < lr) {
      rtri = ltri;
      redg = ledg;
      ltri = 0;
    } else {
      l = -tri_neigh[ltri - 1][ledg - 1];
      rtri = l / 3;
      redg = (l % 3) + 1;
    }
    vbedg(point_xy[m - 1][0], point_xy[m - 1][1],
          point_num, point_xy, tri_num, tri_nodes, tri_neigh,
          &ltri, &ledg, &rtri, &redg);
    n = tri_num + 1;
    l = -tri_neigh[ltri - 1][ledg - 1];
    for (;;) {
      t = l / 3;
      e = (l % 3) + 1;
      l = -tri_neigh[t - 1][e - 1];
      m2 = tri_nodes[t - 1][e - 1];
      if (e <= 2) {
        m1 = tri_nodes[t - 1][e];
      } else {
        m1 = tri_nodes[t - 1][0];
      }
      tri_num++;
      tri_neigh[t - 1][e - 1] = tri_num;
      tri_nodes[tri_num - 1][0] = m1;
      tri_nodes[tri_num - 1][1] = m2;
      tri_nodes[tri_num - 1][2] = m;
      tri_neigh[tri_num - 1][0] = t;
      tri_neigh[tri_num - 1][1] = tri_num - 1;
      tri_neigh[tri_num - 1][2] = tri_num + 1;
      top++;
      assert(point_num >= top);
      stack[top - 1] = tri_num;
      if (t == rtri && e == redg) {
        break;
      }
    }
    tri_neigh[ltri - 1][ledg - 1] = -3*n - 1;
    tri_neigh[n - 1][1] = -3*tri_num - 2;
    tri_neigh[tri_num - 1][2] = -l;
    ltri = n;
    ledg = 2;
    error = swapec(m, &top, &ltri, &ledg, point_num, point_xy,
                   tri_num, tri_nodes, tri_neigh, stack);
    assert(error == 0);
  }
  for (i = 0; i < 3; i++) {
    for (j = 0; j < tri_num; j++) {
      tri_nodes[j][i] = idx[tri_nodes[j][i] - 1];
    }
  }
  perm_inv(point_num, idx);
  permute(point_num, point_xy, idx);
  delete[] idx;
  delete[] stack;
  return tri_num;
}

/*** Wrapper ***/

const double EPS = 1e-9;
#define EQ(a, b) (fabs((a) - (b)) <= EPS)

typedef std::pair<double, double> point;
#define x first
#define y second

struct triangle {
  point a, b, c;

  triangle(const point &a, const point &b, const point &c) : a(a), b(b), c(c) {}

  bool operator==(const triangle &t) const {
    return EQ(a.x, t.a.x) && EQ(a.y, t.a.y) &&
           EQ(b.x, t.b.x) && EQ(b.y, t.b.y) &&
           EQ(c.x, t.c.x) && EQ(c.y, t.c.y);
  }
};

template<class It>
std::vector<triangle> delaunay_triangulation(It lo, It hi) {
  int n = hi - lo;
  double points[n][2];
  int tri_nodes[3*n][3], tri_neigh[3*n][3];
  int curr = 0;
  for (It it = lo; it != hi; ++curr, ++it) {
    points[curr][0] = it->x;
    points[curr][1] = it->y;
  }
  int m = dtris2(n, points, tri_nodes, tri_neigh);
  std::vector<triangle> res;
  for (int i = 0; i < m; i++) {
    res.push_back(triangle(lo[tri_nodes[i][0] - 1],
                           lo[tri_nodes[i][1] - 1],
                           lo[tri_nodes[i][2] - 1]));
  }
  return res;
}

/*** Example Usage ***/

#include <cassert>
using namespace std;

int main() {
  vector<point> v;
  v.push_back(point(1, 3));
  v.push_back(point(1, 2));
  v.push_back(point(2, 1));
  v.push_back(point(0, 0));
  v.push_back(point(-1, 3));
  vector<triangle> t;
  t.push_back(triangle(point(-1, 3), point(0, 0), point(1, 2)));
  t.push_back(triangle(point(-1, 3), point(1, 2), point(1, 3)));
  t.push_back(triangle(point(1, 2), point(0, 0), point(2, 1)));
  t.push_back(triangle(point(1, 3), point(1, 2), point(2, 1)));
  assert(delaunay_triangulation(v.begin(), v.end()) == t);
  return 0;
}
\end{lstlisting}
